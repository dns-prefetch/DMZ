
set term off
/*
  Author:   Michael Hartley
  Date:     Fri, 15 Jul 2022 13:23:28 GMT
  Synopsis: Migration Check List, should be run from a SYSDBA account.

            The runtime of mcl.sql depends on the number of database objects and the performance of your platform, the number of rows in tables is not a factor.  In general this
            script takes between 30 seconds and 40 minutes, on average, completing within 2 minutes

            This script is read-only,
              it does SELECT
              it does NOT insert
              it does NOT update
              it does NOT delete
              it does NOT alter
              it does NOT create
              it does NOT drop
              it does NOT grant
              it does NOT revoke


            There are 3 connection options.
              1. use sysdba for databases you install and manage
              2. use admin for automous databases
              3. create and use fjauditor for autonomous databases
                    create user fjauditor identified by <your-password-here>;
                    grant CREATE SESSION to fjauditor;
                    grant SELECT on SYS.REGISTRY$HISTORY to fjauditor;
                    grant SELECT_CATALOG_ROLE to fjauditor;
                    grant DV_SECANALYST to fjauditor;
                    grant AUDIT_VIEWER to fjauditor;
                    grant CAPTURE_ADMIN to fjauditor;
                    grant SELECT on DBA_USERS_WITH_DEFPWD to fjauditor;

            There is no need to enable dbms_output or start a spool file, all this is done for you.
            e.g.
                connect un/pw@//hostname:port/service_name as sysdba
                connect un/pw@db as sysdba
                connect / as sysdba
                connect fjauditor/<your-password-here>@tns-alias


                SQL> @mcl.sql
                  or
                SQL> @mcl.sql <schema_name_1> <schema_name_2> <schema_name_3>

                Finished. The spool file is mcl.html
                SQL>

                Then ZIP with encryption
                zip -e mcl.zip mcl.html

                <schema_name_1> is optional.
                <schema_name_2> is optional.
                <schema_name_3> is optional.
                  When supplied, (ScriptName) will filter using the schema_name and try to collect meta data for only the filtered schema.


  Modification history: is maintained in a-change-history.txt

  Do not edit "Migration Check List" directly.  As this script is generated by combining a number of individual scripts, the script will
  be overwritten by each build run.

*/
set term on
set term off

set arraysize 200
set colsep ","
set echo off
set feedback off
set flush off
set heading on
set linesize 5000
set pagesize 2000
--set serveroutput on format truncated
set serveroutput on size 1000000 format wrapped
set trimout on
set trimspool on
set verify off
set wrap off
set timing on

define time_start
define time_stop
define version="Fri, 15 Jul 2022 13:23:28 GMT"

set truncate off
set numwidth 15

SET MARKUP HTML ON PREFORMAT OFF ENTMAP OFF SPOOL ON HEAD " -
<meta name='author' content='Michael Hartley'> -
<meta name='version' content='Fri, 15 Jul 2022 13:23:28 GMT'> -
<meta name='title' content='Migration Check List'> -
<title>Migration Check List</title> -
<style id=myStyles>.x {border: solid 1px black;width: 300px;height: 300px;}</style>" -
BODY "" -
TABLE "class='TT'"

alter session set NLS_TERRITORY="UNITED KINGDOM";
alter session set NLS_DATE_LANGUAGE="ENGLISH";
alter session set NLS_DATE_FORMAT='YYYY-MM-DD HH24:Mi:SS';

column data_type format a30
COLUMN db_link format A15
COLUMN host format A30
COLUMN hour format A5
COLUMN object format a30
COLUMN object_name format a30
COLUMN owner format a30
COLUMN statistic_name format a30
COLUMN table_name format a30
COLUMN time_start NEW_VALUE time_start noprint
COLUMN time_stop NEW_VALUE time_stop noprint
COLUMN time_elapsed NEW_VALUE time_elapsed noprint
COLUMN type format a18
COLUMN username format A20
COLUMN AgentFilter NEW_VALUE AgentFilter

COLUMN a new_value 1
COLUMN b new_value 2
COLUMN c new_value 3

select null a, null b, null c from dual where  1=2;
select nvl(upper('&1'),'undefined') a, nvl(upper('&2'),'undefined') b, nvl(upper('&3'),'undefined') c from dual;
select decode('&1','undefined','','and a.username in (''&1'', ''&2'', ''&3'')') AgentFilter from dual;

select to_char(sysdate,'dd-mon-yyyy hh24:mi:ss') time_start from dual;

--set markup HTML OFF
--set term ON
--prompt Migration Check List parameters: 1=&1 2=&2 3=&3 SchemaFilter=&AgentFilter
--set term OFF
--set markup HTML ON

spool mcl.html
prompt <a id="z-header"/>

prompt

--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>
--.s1:  Migration Check List
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>

prompt <img width=100% height=120px src="https://dns-prefetch.github.io/assets/logos/mcl.svg" alt="mcl"/>
prompt <button class="button" id="myBtn">Migration Check List</button>

prompt <!-- The Modal -->

set markup HTML OFF
set timing OFF

DECLARE

  html_td_write_count NUMBER;
  m                   SYS_REFCURSOR;
  buffer              VARCHAR2(255);


  /*
    ------------------------------------------------------------------------
      Below are are the HTML utilities.  So that I do not have to keep
      writing HTML components the generic procedures can be reused.  The
      output generated here should be sympathetic to any CSS code included
      in the HTML output.
    ------------------------------------------------------------------------
  */

  PROCEDURE m_put_line(in_string IN VARCHAR2) IS

    str_len    NUMBER;
    loop_count NUMBER DEFAULT 0;

  BEGIN

    --Flush the buffer

    str_len    := nvl(length(buffer),
                      0);
    loop_count := 0;
    WHILE loop_count < str_len LOOP
      dbms_output.put_line(substr(buffer,
                                  loop_count + 1,
                                  255));
      loop_count := loop_count + 255;
    END LOOP;
    buffer := '';

    --Flush the in_string
    str_len    := nvl(length(in_string),
                      0);
    loop_count := 0;
    WHILE loop_count < str_len LOOP
      dbms_output.put_line(substr(in_string,
                                  loop_count + 1,
                                  255));
      loop_count := loop_count + 255;
    END LOOP;
  END;

  PROCEDURE m_put(in_string IN VARCHAR2) IS
    buf_len NUMBER;
    str_len NUMBER;

  BEGIN

    buf_len := nvl(length(buffer),
                   0);
    str_len := nvl(length(in_string),
                   0);

    IF ((buf_len + str_len) < 255)
    THEN
      buffer := buffer || in_string;
    ELSE
      m_put_line(in_string);
    END IF;

  END;

  PROCEDURE html_h1(p1 VARCHAR2) IS
  BEGIN
    m_put('<h1>' || TRIM(p1) || '</h1>');
  END;

  PROCEDURE html_h2(p1 VARCHAR2) IS
  BEGIN
    m_put('<h2>' || TRIM(p1) || '</h2>');
  END;

  PROCEDURE html_h3(p1 VARCHAR2) IS
  BEGIN
    m_put('<h3>' || TRIM(p1) || '</h3>');
  END;

  PROCEDURE html_screen_start IS
  BEGIN
    m_put('<div>');
  END;
  PROCEDURE html_screen_stop IS
  BEGIN
    m_put_line('</div>');
  END;
  PROCEDURE html_table_caption(p1 VARCHAR2) IS
  BEGIN
    m_put('<caption>' || TRIM(p1) || '</caption>');
  END;
  PROCEDURE html_paragraph(p1 VARCHAR2) IS
  BEGIN
    m_put_line('<p>' || TRIM(p1) || '</p>');
  END;

  PROCEDURE html_table_start IS
  BEGIN
    m_put('<table class="TT">');
  END;
  PROCEDURE html_table_stop IS
  BEGIN
    m_put_line('</table>');
  END;
  PROCEDURE html_table_row_start IS
  BEGIN
    m_put('<tr>');
  END;
  PROCEDURE html_table_row_stop IS
  BEGIN
    m_put('</tr>');
  END;
  PROCEDURE html_table_header_data(p1 VARCHAR2) IS
  BEGIN
    m_put('<th scope="col">' || TRIM(p1) || '</th>');
  END;
  PROCEDURE html_table_data_start IS
  BEGIN
    html_td_write_count := 0;
    m_put('<td>');
  END;
  PROCEDURE html_table_data_stop IS
  BEGIN
    m_put('</td>');
  END;
  PROCEDURE html_table_data_write(p1 VARCHAR2) IS
  BEGIN
    IF html_td_write_count > 0
    THEN
      m_put(' ');
    ELSE
      html_td_write_count := 1;
    END IF;
    m_put(TRIM(p1));
  END;

  PROCEDURE html_table_data(p1 VARCHAR2) IS
  BEGIN
    html_table_data_start;
    html_table_data_write(TRIM(p1));
    html_table_data_stop;
  END;
  PROCEDURE html_table_data(p1 NUMBER) IS
  BEGIN
    html_table_data(to_char(p1));
  END;

  PROCEDURE html_table_row(a VARCHAR2,
                           b VARCHAR2) IS
  BEGIN
    m_put('<tr><td align="right">' || TRIM(a) || '</td>' || '<td>' || TRIM(b) || '</td></tr>');
  END;

  PROCEDURE html_header_row(a VARCHAR2, b VARCHAR2) IS
  BEGIN
    html_table_row_start;
    html_table_header_data(TRIM(a));
    html_table_header_data(TRIM(b));
    html_table_row_stop;
  END;

  PROCEDURE html_2_col_header(a VARCHAR2,
                              b VARCHAR2) IS
  BEGIN
    html_table_row_start;
    html_table_header_data(a);
    html_table_header_data(b);
    html_table_row_stop;
  END;

  PROCEDURE user_session IS

    svalue VARCHAR2(4000);

  BEGIN

    html_table_row('Document Compiled',to_char(sysdate,'Day dd Month yyyy hh24:mi'));
    html_table_row('Schema Filter',Q'[&AgentFilter]');

    FOR rs IN (SELECT column_value RESULT
               FROM   TABLE(sys.dbms_debug_vc2coll('ACTION',
                                                   'AUDITED_CURSORID',
                                                   'AUTHENTICATED_IDENTITY',
                                                   'AUTHENTICATION_DATA',
                                                   'AUTHENTICATION_METHOD',
                                                   'AUTHENTICATION_TYPE',
                                                   'BG_JOB_ID',
                                                   'CLIENT_IDENTIFIER',
                                                   'CLIENT_INFO',
                                                   'CURRENT_BIND',
                                                   'CURRENT_SCHEMA',
                                                   'CURRENT_SQL',
                                                   'CURRENT_SQL_LENGTH',
                                                   'CURRENT_USER',
                                                   'DB_DOMAIN',
                                                   'DB_NAME',
                                                   'DB_UNIQUE_NAME',
                                                   'ENTERPRISE_IDENTITY',
                                                   'EXTERNAL_NAME',
                                                   'GLOBAL_UID',
                                                   'HOST',
                                                   'IDENTIFICATION_TYPE',
                                                   'INSTANCE',
                                                   'INSTANCE_NAME',
                                                   'IP_ADDRESS',
                                                   'ISDBA',
                                                   'LANG',
                                                   'LANGUAGE',
                                                   'MODULE',
                                                   'NETWORK_PROTOCOL',
                                                   --'NLS_CALENDAR',
                                                   'NLS_CURRENCY',
                                                   'NLS_DATE_FORMAT',
                                                   'NLS_DATE_LANGUAGE',
                                                   --'NLS_SORT',
                                                   'NLS_TERRITORY',
                                                   'OS_USER',
                                                   'POLICY_INVOKER',
                                                   'PROXY_ENTERPRISE_IDENTITY',
                                                   'PROXY_GLOBAL_UID',
                                                   'PROXY_USER',
                                                   'PROXY_USERID',
                                                   'SERVER_HOST',
                                                   'SERVICE_NAME',
                                                   'SESSIONID',
                                                   --'SESSION_USER',
                                                   'SESSION_USERID',
                                                   --'SID',
                                                   'STATEMENTID',
                                                   'TERMINAL'))) LOOP

      BEGIN
        SELECT sys_context('USERENV',
                           rs.result)
        INTO   svalue
        FROM   dual;

        IF (svalue IS NOT NULL)
        THEN
          html_table_row(rs.result,
                         svalue);
        END IF;

      EXCEPTION
        WHEN OTHERS THEN
          NULL;
      END;
    END LOOP;

      FOR rs IN (SELECT username,
                      machine,
                      program,
                      module,
                      action,
                      client_info
               FROM   v$session
               WHERE  sid = (SELECT sid FROM v$mystat WHERE rownum = 1)) LOOP
      html_table_row('PROGRAM',rs.program);
    END LOOP;

  END;

  PROCEDURE modal_start IS
  BEGIN
    m_put('<div id="myModal" class="modal"><div class="modal-content">');
    m_put('<table><tr valign=top><td>');

    html_table_start;
    html_table_caption('Session information');
    html_header_row('USRENV Parameter',
                    'Value');
    user_session;
    html_table_stop;

    m_put('</td>');
    m_put('<td>');
  END;
  PROCEDURE modal_stop IS
  BEGIN
    m_put_line('</div></div>');
  END;
  PROCEDURE modal_header(header VARCHAR2) IS
  BEGIN
    m_put('<div class="modal-header"><span class="close"></span>');
    m_put('<b>' || header || '</b>');
    m_put('</div>');
  END;
  PROCEDURE modal_footer(footer VARCHAR2) IS
  BEGIN
    m_put('<div class="modal-footer">');
    html_paragraph(footer);
    m_put('</div>');
  END;
  PROCEDURE modal_body_start IS
  BEGIN
    m_put('<div class="modal-body">');
  END;
  PROCEDURE modal_body_stop IS
  BEGIN
    m_put('</td>');
    m_put('</tr>');
    m_put('</table>');
    m_put('</div>');
  END;
  procedure svg_image IS
  BEGIN
    m_put('<svg xmlns="http://www.w3.org/2000/svg" width="3cm" height="3cm"> <rect fill="#3C81C1" x="0" y="0" width="50" height="75"><animateTransform attributeName="transform" type="translate" from="-50 -50" to="150 120" begin="0s" dur="2s" repeatCount="indefinite" /> </rect> <circle id="my-circle" r=".5cm" cx="1.5cm" cy="1.5cm" fill="orange"> <animateTransform attributeName="transform" type="translate" from="-50 -50" to="150 20" begin="0s" dur="2s" repeatCount="indefinite" /> </circle> <g style="fill-opacity:0.7; stroke:black; stroke-width:1px;"> <circle cx="1.5cm" cy="1.5cm" r="1cm" style="fill:red;"  transform="translate(0,-25)" /> <circle cx="1.5cm" cy="1.5cm" r="1cm" style="fill:blue;" transform="translate(35,30)" /> <circle cx="1.5cm" cy="1.5cm" r="1cm" style="fill:green;" transform="translate(-35,30)"/> </g> </svg>');
  end;

BEGIN
  modal_start;
  modal_header('Migration Check List');
  modal_body_start;
  html_paragraph('About.  What does it mean to be a "Migration Check List"');
  html_table_start;
  html_table_caption('FAQ');
  html_table_row('.Q.',
                    '.A.');
  html_table_row('Who am I',
                 'Migration Check List');
  html_table_row('What is my version',
                 '2206');
  html_table_row('What is my patch date',
                 'Fri, 15 Jul 2022 13:23:28 GMT');
  html_table_row('Who is my creator',
                 'Michael Hartley');
  html_table_row('Why am I here',
                 'In 2014, the author was writing migration gap analysis documents and was struggling to collect information he needed, so he started writing your code.');
  html_table_row('What does my version number mean?','Your version is incremented roughly every 6 months, around January and June every year.  The four digits are the year and month you were created.');
  html_table_row('What does my patch date mean?','Sometimes the author accidentally leaves a gremlin in your code, and eventually he fixes this gremlin.  The patch date represents your last build date, hopefully a date when you had some gremlins removed.');
  html_table_row('Roger that','Out');
  html_table_stop;
  svg_image;
  html_paragraph('Click outside the dialog box to close.');
  modal_body_stop;
  modal_footer('Have a great day.');
  modal_stop;

END;
/
set markup HTML ON
set timing ON

prompt <script>var modal = document.getElementById('myModal');var btn = document.getElementById("myBtn");var span = document.getElementsByClassName("close")[0];btn.onclick = function() {modal.style.display = "block";};span.onclick = function() {modal.style.display = "none";};window.onclick = function(event) {if (event.target == modal) {modal.style.display = "none";}};</script>

prompt
set markup HTML OFF
prompt <div id='Menu1'></div>
set markup HTML ON
prompt
prompt This script is read-only against the database catalogue, database objects are not created or modified.  There is no attempt to capture information contained within an application schema, other than table and column names.  If you have any table or column names that you wish to keep private, simply edit and rename the resulting spool file.  Any gap analysis performed with the data extract by this script does not rely on the table or column names, though the names may be used as points for discussion within a gap analysis document.

prompt
prompt <h1 id="Database_Summary">Database Summary</h1>

prompt
prompt Top level summary of the database configuration and sizing.
prompt

set markup HTML OFF

DECLARE

  --skip=1 when plsql block slow - else leave at 0
  skip NUMBER := 0;

  gb     NUMBER := 1024 * 1024 * 1024;
  ntemp1 NUMBER; --temporary work number
  ntemp2 NUMBER; --temporary work number
  --h1       VARCHAR2(20) := '--------------------';
  h1       VARCHAR2(20) := '<b>Section</b>';
  h2       VARCHAR2(37) := '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~';
  nf       VARCHAR2(30) := '999999999990D90';
  RESULT   VARCHAR2(100);
  sname    VARCHAR2(100);
  t1_start DATE;
  t1_stop  DATE;
  t2_start DATE;

  PROCEDURE print_start IS
  BEGIN
    dbms_output.enable(1000000);
    dbms_output.put_line('<table class="TT"><tr><th scope="col">Parameter</th><th scope="col">Value</th></tr>');
  END;

  PROCEDURE print_stop IS
  BEGIN
    dbms_output.put_line('</table>');
  END;

  PROCEDURE println2(a VARCHAR2,
                     b VARCHAR2) IS
  BEGIN
    --dbms_output.put(lpad(TRIM(a), 40, ' ') || ' , ' || TRIM(b));
    --dbms_output.put_line('');
    dbms_output.put_line('<tr><td align="right">' || TRIM(a) || '</td>' || '<td>' || TRIM(b) || '</td></tr>');
  END;

  --Collect 1 column from single row table.  Survives column missing errors in legacy database versions
  PROCEDURE print_vcol(NAME VARCHAR2,
                       pcol VARCHAR2,
                       ptab VARCHAR2) IS
    RESULT  VARCHAR2(100);
    message VARCHAR2(3) := 'N/A';
  BEGIN
    BEGIN
      EXECUTE IMMEDIATE 'select ' || pcol || ' from ' || ptab
        INTO RESULT;
    EXCEPTION
      WHEN OTHERS THEN
        RESULT := message;
    END;
    println2(NAME,
             RESULT);
  EXCEPTION
    WHEN OTHERS THEN
      NULL;
  END;

  PROCEDURE print_vdynsql(psql VARCHAR2) IS
    /*
      psql returns 2 values: name, value
      as in
      select name, value from v$parameter
    */
    vcursor NUMBER;
    vignore INTEGER;
    vname   VARCHAR2(4000);
    vresult VARCHAR2(4000);
    --message VARCHAR2(3) := 'N/A';
  BEGIN

    vcursor := dbms_sql.open_cursor;

    dbms_sql.parse(vcursor,
                   psql,
                   dbms_sql.native);

    dbms_sql.define_column(vcursor,
                           1,
                           vname,
                           4000);
    dbms_sql.define_column(vcursor,
                           2,
                           vresult,
                           4000);

    vignore := dbms_sql.execute(vcursor);

    LOOP
      EXIT WHEN dbms_sql.fetch_rows(vcursor) = 0;

      dbms_sql.column_value(vcursor,
                            1,
                            vname);
      dbms_sql.column_value(vcursor,
                            2,
                            vresult);
      println2(vname,
               vresult);
    END LOOP;

    dbms_sql.close_cursor(vcursor);
  EXCEPTION
    WHEN OTHERS THEN
      IF (vcursor IS NOT NULL)
      THEN
        dbms_sql.close_cursor(vcursor);
      END IF;
  END;

  PROCEDURE print_db_parameter(pname       VARCHAR2,
                               pdefault    VARCHAR2,
                               pdeprecated VARCHAR2) IS

    /*    CURSOR mycur IS
    SELECT NAME,
           '[N=' || to_char(COUNT(*)) || '] ' || VALUE VALUE
    FROM   gv$parameter
    WHERE  NAME LIKE pname
           AND isdefault = pdefault
           AND isdeprecated = pdeprecated
    GROUP  BY NAME,
              VALUE
    ORDER  BY NAME,
              VALUE;*/

  BEGIN

    IF (pdeprecated = 'TRUE')
    THEN
      print_vdynsql('SELECT NAME, ''[N='' || to_char(COUNT(*)) || ''] '' || VALUE FROM gv$parameter WHERE NAME LIKE ''' ||
                    pname || ''' AND isdefault = ''' || pdefault ||
                    ''' AND isdeprecated = ''TRUE'' GROUP  BY NAME, VALUE ORDER  BY NAME, VALUE');

    ELSE
      print_vdynsql('SELECT NAME, ''[N='' || to_char(COUNT(*)) || ''] '' || VALUE FROM gv$parameter WHERE NAME LIKE ''' ||
                    pname || ''' AND isdefault = ''' || pdefault || ''' GROUP  BY NAME, VALUE ORDER  BY NAME, VALUE');

    END IF;

  EXCEPTION
    WHEN OTHERS THEN
      println2(pname,
               SQLERRM);
  END;

  PROCEDURE db IS

  BEGIN
    println2(h1,
             '+- db -+');

    --server_host 10g+ parameter
    print_vcol('Database host',
               'sys_context(''USERENV'',''SERVER_HOST'',30)',
               'dual');
    print_vcol('Host name',
               'host_name',
               'v$instance');
    print_vcol('Platform name',
               'platform_name',
               'v$database');
    print_vcol('Operating system and two task protocol version',
               'dbms_utility.port_string',
               'v$database');
    print_vcol('CPU Socket Core Count',
               'cpu_socket_count_current',
               'v$license');
    print_vcol('CPU Count',
               'cpu_count_current',
               'v$license');
    print_vcol('CPU Endian Format',
               'endian_format',
               'V$TRANSPORTABLE_PLATFORM where platform_id = (select platform_id from v$database)');
    print_vcol('Physical memory(gb)',
               'round(value/1024/1024/1024,2)',
               'v$osstat where stat_name = ''PHYSICAL_MEMORY_BYTES''');

    print_vcol('SGA + PGA(now) usage mb',
               'round(((select value from V$PGASTAT where name = ''total PGA inuse'') + (select sum(value) from v$sga))/1024/1024/1024,2)',
               'dual');
    print_vcol('SGA + PGA(max) usage mb',
               'round(((select value from V$PGASTAT where name = ''maximum PGA allocated'') + (select sum(value) from v$sga))/1024/1024/1024,2)',
               'dual');

    print_vcol('Database name',
               'name',
               'v$database');
    print_vcol('Unique name',
               'db_unique_name',
               'v$database');
    --SELECT banner INTO RESULT FROM v$version WHERE rownum = 1;
    --println2('Database version', RESULT);
    print_vcol('Database version',
               'banner',
               'v$version where rownum = 1');
    print_vcol('Created',
               'to_char(created, ''yyyy-mm-dd hh24:mi'')',
               'v$database');
    print_vcol('Age years',
               'to_char(round((SYSDATE - created) / 365, 4), ''90D90'')',
               'v$database');
    print_vcol('Time zone',
               'dbtimezone',
               'dual');
    print_vcol('Time zone version',
               'version',
               'v$timezone_file');
    print_vcol('Time zone Filename',
               'filename',
               'v$timezone_file');
    print_vcol('User count',
               'count(*)',
               'dba_users where username in (SELECT a.username FROM dba_users a, dba_users b WHERE a.created > (b.created + 1 / 24) AND b.username = ''SYS'' MINUS SELECT DISTINCT SCHEMA FROM dba_registry)');

    print_vcol('Startup time',
               'to_char(startup_time, ''yyyy-mm-dd hh24:mi'')',
               'v$instance');
    print_vcol('Open mode',
               'open_mode',
               'v$database');
    print_vcol('Current SCN',
               'current_scn || '' '' || ''AVG/y('' || round(current_scn / ((SYSDATE - created) / 365)) || '')'' || '' '' || ''AVG/m('' || round(current_scn / ((SYSDATE - created) / 365 * 12)) || '')'' || '' '' || ''AVG/d('' || round(current_scn / ((SYSDATE - created))) || '')'' || '' '' || ''AVG/hr('' || round(current_scn / ((SYSDATE - created) * 24)) || '')''',
               'v$database');
  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE cdb IS

  BEGIN
    println2(h1,
             '+- cdb -+');
    print_vcol('Am I a CDB',
               'cdb',
               'v$database');
    print_vcol('Container name',
               'sys_context(''USERENV'',''CON_NAME'',30)',
               'dual');
    --print_vdynsql('select ''container '' || con_id, name from v$containers');
    print_vdynsql('select ''container '' || con_id, name || '' ['' || round(total_size/1024/1024/1024,2) || '' gb]'' from v$containers');

  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE db_characters IS
    CURSOR mycur IS
      SELECT lower(parameter) sname,
             VALUE RESULT
      FROM   v$nls_parameters
      WHERE  parameter IN ('NLS_CHARACTERSET',
                           'NLS_LANGUAGE',
                           'NLS_NCHAR_CHARACTERSET',
                           'NLS_TERRITORY');

  BEGIN
    println2(h1,
             '+- db character set -+');
    FOR myrows IN mycur LOOP
      println2(myrows.sname,
               myrows.result);
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE db_logging IS

    CURSOR mycur0 IS
      SELECT COUNT(*) total,
             members || ' members of ' || round(bytes / 1024 / 1024,
                                                2) || ' mb' VALUE
      FROM   v$log
      GROUP  BY members || ' members of ' || round(bytes / 1024 / 1024,
                                                   2) || ' mb';

    CURSOR mycur1 IS
      SELECT COUNT(*) total,
             round(bytes / 1024 / 1024,
                   2) || ' mb' VALUE
      FROM   v$standby_log
      GROUP  BY round(bytes / 1024 / 1024,
                      2) || ' mb';

    CURSOR mycur2 IS
      SELECT dest_id,
             MIN(mbytes) min_mb,
             round(AVG(mbytes)) avg_mb,
             MAX(mbytes) max_mb,
             MIN(switches) min_swtch,
             round(AVG(switches)) avg_swtch,
             MAX(switches) max_swtch
      FROM   (SELECT dest_id,
                     trunc(completion_time,
                           'hh24') period,
                     round(SUM(blocks * block_size) / 1024 / 1024) mbytes,
                     COUNT(*) switches
              FROM   v$archived_log
              GROUP  BY dest_id,
                        trunc(completion_time,
                              'hh24'))
      GROUP  BY dest_id
      ORDER  BY 1;

  BEGIN
    println2(h1,
             '+- db logging -+');

    --FOR myrows IN mycur1 LOOP
    --  println2('Archive log hourly mb', myrows.result);
    --END LOOP;

    print_vcol('Log mode',
               'log_mode',
               'v$database');
    print_vcol('Flashback on',
               'flashback_on',
               'v$database');
    print_vcol('Force logging',
               'force_logging',
               'v$database');
    print_vcol('Block Change Tracking',
               'status',
               'v$block_change_tracking');
    print_vcol('Supplemental log data all',
               'supplemental_log_data_all',
               'v$database');
    print_vcol('Supplemental log data fk',
               'supplemental_log_data_fk',
               'v$database');
    print_vcol('Supplemental log data min',
               'supplemental_log_data_min',
               'v$database');
    print_vcol('Supplemental log data pk',
               'supplemental_log_data_pk',
               'v$database');
    print_vcol('Supplemental log data ui',
               'supplemental_log_data_ui',
               'v$database');

    --Log group review
    FOR myrows IN mycur0 LOOP
      println2(myrows.total || ' log Groups',
               myrows.value);
    END LOOP;

    --standby Log group review
    FOR myrows IN mycur1 LOOP
      println2(myrows.total || ' standby log Groups',
               myrows.value);
    END LOOP;

    --Archive log activity review
    FOR myrows IN mycur2 LOOP
      println2('Archivelog dest ' || myrows.dest_id || ' in mb/hour',
               'min(' || myrows.min_mb || '), ' || 'avg(' || myrows.avg_mb || '), ' || 'max(' || myrows.max_mb || ')');
      println2('Archivelog dest ' || myrows.dest_id || ' switches/hour',
               'min(' || myrows.min_swtch || '), ' || 'avg(' || myrows.avg_swtch || '), ' || 'max(' || myrows.max_swtch || ')');
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE db_files IS

  cursor mycur1 is
  SELECT lower(subset) || ' gb' name,
       round(bsize / 1024 / 1024 / 1024,
             2) value
        FROM   (SELECT tablespace_name subset,
               SUM(bytes) bsize
        FROM   dba_temp_files
        GROUP  BY tablespace_name
        UNION
        SELECT 'Application Tablespaces' subset,
               SUM(bytes) bsize
        FROM   dba_data_files
        WHERE  tablespace_name NOT IN ('SYSAUX',
                                       'SYSTEM')
               AND tablespace_name NOT IN (SELECT VALUE FROM v$parameter WHERE NAME = 'undo_tablespace')
        UNION
        SELECT tablespace_name subset,
               SUM(bytes) bsize
        FROM   dba_data_files
        WHERE  tablespace_name IN ('SYSAUX',
                                   'SYSTEM')
        GROUP  BY tablespace_name
        UNION
        SELECT tablespace_name subset,
               SUM(bytes) bsize
        FROM   dba_data_files
        WHERE  tablespace_name IN (SELECT VALUE FROM v$parameter WHERE NAME = 'undo_tablespace')
        GROUP  BY tablespace_name
        UNION
        SELECT 'Online Redo Logs' subset,
               SUM(bytes * members) bsize
        FROM   v$log)
;


  BEGIN
    println2(h1,
             '+- db tablespace footprint -+');

    SELECT (rlog.bytes + df.bytes + tf.bytes) / gb
    INTO   ntemp1
    FROM   (SELECT SUM(a.bytes) bytes
            FROM   v$log     a,
                   v$logfile b
            WHERE  a.group# = b.group#) rlog,
           (SELECT SUM(bytes) bytes FROM dba_data_files) df,
           (SELECT SUM(bytes) bytes FROM dba_temp_files) tf;

    println2('db disk space gb',
             to_char(ntemp1,
                     nf));

    SELECT SUM(bytes) / gb
    INTO   ntemp2
    FROM   dba_free_space
    WHERE  tablespace_name NOT IN ('SYSTEM',
                                   'SYSAUX')
           AND tablespace_name NOT IN (SELECT VALUE FROM gv$parameter WHERE NAME = 'undo_tablespace');

    println2('db free space gb',
             to_char(ntemp2,
                     nf));

    println2('db free space percentage',
             to_char((ntemp2 / ntemp1 * 100),
                     nf));

  --9i fix - if script  run against 9i this procedure will not abend
  print_vdynsql('SELECT ''control files'' subset, round(SUM(block_size * file_size_blks)/1024/1024/1024,2) bsize FROM v$controlfile');

     FOR myrows IN mycur1 LOOP
        println2(myrows.name,
                 myrows.value);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

  PROCEDURE db_segments IS
  BEGIN
    println2(h1,
             '+- db application segments -+');

    --select 'db_indexes_gb',to_char(sum(bytes)/gb,nf) into sname, result from dba_segments where segment_type like '%INDEX%' and owner not in (select schema from dba_registry); println2( sname, result);
    --select 'db_lob_data_gb', to_char(sum(bytes)/gb,nf) into sname, result from dba_segments where segment_type in ('LOB PARTITION','LOBSEGMENT') and owner not in (select schema from dba_registry); println2( sname, result);
    --select 'db_table_data_gb', to_char(sum(bytes)/gb,nf) into sname, result from dba_segments where segment_type like '%TABLE%' and owner not in (select schema from dba_registry); println2( sname, result);

    FOR myrows IN (SELECT DISTINCT segment_type
                   FROM   dba_segments
                   WHERE  segment_type NOT IN ('ROLLBACK',
                                               'TYPE2 UNDO')
                   ORDER  BY 1) LOOP
      SELECT lower(myrows.segment_type) || ' gb',
             nvl(to_char(SUM(bytes) / gb,
                         nf),
                 '0')
      INTO   sname,
             RESULT
      FROM   dba_segments
      WHERE  segment_type = myrows.segment_type
             AND owner IN (SELECT a.username
                           FROM   dba_users a,
                                  dba_users b
                           WHERE  a.created > (b.created + 1 / 24)
                                  AND b.username = 'SYS' &AgentFilter
                           MINUS
                           SELECT DISTINCT SCHEMA
                           FROM   dba_registry);
      println2(sname,
               RESULT);
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE db_registry_size IS
    cursor mycur1 is SELECT comp_name || ' (' || owner || ') gb' name,  SUM(bytes)/gb value FROM dba_segments s, dba_registry r WHERE s.owner = r.schema  AND r.schema != 'SYS' group by comp_name || ' (' || owner || ') gb';
  BEGIN
    println2(h1,
             '+- db registry segments -+');

    for rs in mycur1 LOOP
      println2(rs.name, to_char(rs.value,nf));
    end loop;

  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE asm IS
    /*    CURSOR mycur_1 IS
    SELECT NAME,
           'total_gb=' || to_char(round(total_mb / 1024)) || ' ' || 'used_gb=' ||
           to_char(round((total_mb - free_mb) / 1024)) || ' ' || 'free_gb=' || to_char(round(free_mb / 1024)) VALUE
    FROM   v$asm_diskgroup;*/

  BEGIN
    println2(h1,
             '+- ASM -+');

    print_vdynsql('SELECT NAME,
             '' total_gb = '' || to_char(round(total_mb / 1024)) || '' '' || ''
                  used_gb = '' ||
             to_char(round((total_mb - free_mb) / 1024)) || '' '' || ''
                  free_gb = '' || to_char(round(free_mb / 1024)) VALUE
      FROM   v$asm_diskgroup');

  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE db_config IS

    CURSOR mycur_hidden IS
      SELECT ksppinm NAME,
             '[N=' || COUNT(*) || '] ' || kspftctxvl || ' [' || ksppdesc || ' ' || b.kspftctxct || ']' VALUE
      FROM   sys.x$ksppi   a,
             sys.x$ksppcv2 b
      WHERE  (a.indx + 1) = b.kspftctxpn
             AND a.ksppinm LIKE '\_%' ESCAPE '\'
             AND b.kspftctxdf = 'FALSE'
      GROUP  BY ksppinm,
                kspftctxvl,
                ksppdesc,
                b.kspftctxct
      ORDER  BY 1,
                2;

BEGIN
  --print_db_parameter('name', isdefault, isdeprecated);

  println2(h1, '+- db parameters -+');

  println2(h1, '++ General ++');
    print_db_parameter('compatible', 'FALSE', 'FALSE');
    print_db_parameter('cursor_sharing', 'FALSE', 'FALSE');
    print_db_parameter('db_block_size', 'FALSE', 'FALSE');
    print_db_parameter('db_cache_advice', 'FALSE', 'FALSE');
    print_db_parameter('db_cache_size', 'FALSE', 'FALSE');
    print_db_parameter('db_file_multiblock_read_count', 'FALSE', 'FALSE');
    print_db_parameter('db_keep_cache_size', 'FALSE', 'FALSE');
    print_db_parameter('db_writer_processes', 'FALSE', 'FALSE');
    print_db_parameter('dispatchers', 'FALSE', 'FALSE');
    print_db_parameter('log_archive_format', 'FALSE', 'FALSE');
    print_db_parameter('log_buffer', 'FALSE', 'FALSE');
    print_db_parameter('log_parallelism', 'FALSE', 'FALSE');
    print_db_parameter('open_cursors', 'FALSE', 'FALSE');
    print_db_parameter('optimizer_dynamic_sampling', 'FALSE', 'FALSE');
    print_db_parameter('optimizer_features_enable', 'FALSE', 'FALSE');
    print_db_parameter('optimizer_index_caching', 'FALSE', 'FALSE');
    print_db_parameter('optimizer_index_cost_adjust', 'FALSE', 'FALSE');
    print_db_parameter('optimizer_mode', 'FALSE', 'FALSE');
    print_db_parameter('parallel_execution_message_size', 'FALSE', 'FALSE');
    print_db_parameter('parallel_max_servers', 'FALSE', 'FALSE');
    print_db_parameter('parallel_min_servers', 'FALSE', 'FALSE');
    print_db_parameter('processes', 'FALSE', 'FALSE');
    print_db_parameter('query_rewrite_enabled', 'FALSE', 'FALSE');
    print_db_parameter('query_rewrite_integrity', 'FALSE', 'FALSE');
    print_db_parameter('recyclebin', 'FALSE', 'FALSE');
    print_db_parameter('session_cached_cursors', 'FALSE', 'FALSE');
    print_db_parameter('sessions', 'FALSE', 'FALSE');
    print_db_parameter('star_transformation_enabled', 'FALSE', 'FALSE');
    print_db_parameter('statistics_level', 'FALSE', 'FALSE');
    print_db_parameter('undo_management', 'FALSE', 'FALSE');
    print_db_parameter('undo_retention', 'FALSE', 'FALSE');
    print_db_parameter('workarea_size_policy', 'FALSE', 'FALSE');

  println2(h1, '++ Networking ++');

    print_db_parameter('dispatchers', 'FALSE', 'FALSE');
    print_db_parameter('fileio_network_adapters', 'FALSE', 'FALSE');
    print_db_parameter('forward_listener', 'FALSE', 'FALSE');
    print_db_parameter('listener_networks', 'FALSE', 'FALSE');
    print_db_parameter('local_listener', 'FALSE', 'FALSE');
    print_db_parameter('max_shared_servers', 'FALSE', 'FALSE');
    print_db_parameter('remote_listener', 'FALSE', 'FALSE');
    print_db_parameter('shared_servers', 'FALSE', 'FALSE');

  println2(h1, '++ Memory ++');

    print_db_parameter('memory_max_target', 'FALSE', 'FALSE');
    print_db_parameter('memory_target', 'FALSE', 'FALSE');
    print_db_parameter('pga_aggregate_target', 'FALSE', 'FALSE');
    print_db_parameter('sga_max_size', 'FALSE', 'FALSE');
    print_db_parameter('sga_target', 'FALSE', 'FALSE');
    print_db_parameter('shared_pool_reserved_size', 'FALSE', 'FALSE');
    print_db_parameter('shared_pool_size', 'FALSE', 'FALSE');
    print_db_parameter('sort_area_size', 'FALSE', 'FALSE');
    print_db_parameter('use_large_pages', 'FALSE', 'FALSE');

  println2(h1, '++ File Destinations ++');

    print_db_parameter('audit_file_dest', 'FALSE', 'FALSE');
    print_db_parameter('background_dump_dest', 'FALSE', 'FALSE');
    print_db_parameter('control_files', 'FALSE', 'FALSE');
    print_db_parameter('core_dump_dest', 'FALSE', 'FALSE');
    print_db_parameter('db_create_file_dest', 'FALSE', 'FALSE');
    print_db_parameter('db_recovery_file_dest', 'FALSE', 'FALSE');
    print_db_parameter('spfile', 'FALSE', 'FALSE');
    print_db_parameter('user_dump_dest', 'FALSE', 'FALSE');

  println2(h1, '++ CPU caging and resource limits ++');

    print_db_parameter('cpu_count', 'FALSE', 'FALSE');
    print_db_parameter('resource_limit', 'FALSE', 'FALSE');
    print_db_parameter('resource_manager_cpu_allocation', 'FALSE', 'FALSE');
    print_db_parameter('resource_manager_plan', 'FALSE', 'FALSE');

  println2(h1, '++ SQL tuning ++');

    print_db_parameter('optimizer_capture_sql_plan_baselines', 'FALSE', 'FALSE');
    print_db_parameter('optimizer_dynamic_sampling', 'FALSE', 'FALSE');
    print_db_parameter('optimizer_use_sql_plan_baselines', 'FALSE', 'FALSE');
    print_db_parameter('plsql_code_type', 'FALSE', 'FALSE');
    print_db_parameter('plsql_optimize_level', 'FALSE', 'FALSE');

  println2(h1, '++ Deprecated - in use ++');

    print_db_parameter('%', 'FALSE', 'TRUE');

  println2(h1, '++ Hidden underscore - in use ++');
  BEGIN
    FOR myrows IN mycur_hidden LOOP
      println2(myrows.name, myrows.value);
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception', SQLERRM);
  END;

  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE db_rac IS

    CURSOR cur_nodes IS
      SELECT instance_name || '(' || host_name || ')' VALUE FROM gv$instance ORDER BY inst_id;

    snodes VARCHAR2(2000);

  BEGIN
    println2(h1,
             '+- RAC configuration -+');
    print_db_parameter('active_instance_count',
                       'FALSE',
                       'FALSE');
    print_db_parameter('cluster_database',
                       'FALSE',
                       'FALSE');
    print_db_parameter('cluster_database_instances',
                       'FALSE',
                       'FALSE');
    print_db_parameter('cluster_interconect',
                       'FALSE',
                       'FALSE');

    snodes := '';
    FOR myrows IN cur_nodes LOOP
      snodes := snodes || myrows.value || ' ';
    END LOOP;
    println2('RAC nodes',
             snodes);

  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE db_dg IS

  BEGIN
    println2(h1,
             '+- Data Guard configuration -+');
    print_db_parameter('archive_lag_target',
                       'FALSE',
                       'FALSE');
    print_db_parameter('control_file_record_keep_time',
                       'FALSE',
                       'FALSE');
    print_db_parameter('db_file_name_convert',
                       'FALSE',
                       'FALSE');
    print_db_parameter('db_unique_name',
                       'FALSE',
                       'FALSE');
    print_db_parameter('dg_broker%',
                       'FALSE',
                       'FALSE');
    print_db_parameter('fal%',
                       'FALSE',
                       'FALSE');
    print_db_parameter('log_archive%',
                       'FALSE',
                       'FALSE');
    print_db_parameter('log_file%',
                       'FALSE',
                       'FALSE');
    print_db_parameter('remote_login_passwordfile',
                       'FALSE',
                       'FALSE');
    print_db_parameter('standby_archive_dest',
                       'FALSE',
                       'FALSE');
    print_db_parameter('standby_file_management',
                       'FALSE',
                       'FALSE');

    print_vcol('Database Instance','INSTANCE', 'v$database');
    print_vcol('Database Role','DATABASE_ROLE', 'v$database');
    print_vcol('Database Unique Name','DB_UNIQUE_NAME', 'v$database');
    print_vcol('Dataguard Broker','dataguard_broker','v$database');
    print_vcol('Guard Status', 'guard_status', 'v$database');
    print_vcol('Open Mode','OPEN_MODE', 'v$database');
    print_vcol('Protection Level','PROTECTION_LEVEL', 'v$database');
    print_vcol('Protection Mode','PROTECTION_MODE', 'v$database');
    print_vcol('Switchover Status','SWITCHOVER_STATUS', 'v$database');

  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE db_logical_standby IS

    CURSOR mycur1 IS
      SELECT COUNT(*) VALUE FROM dba_logstdby_not_unique WHERE bad_column = 'Y';

    /*    CURSOR mycur2 IS
    SELECT nvl(attributes,
               data_type) NAME,
           COUNT(*) VALUE
    FROM   dba_logstdby_unsupported
    GROUP  BY nvl(attributes,
                  data_type)
    ORDER  BY 1;*/

    CURSOR mycur2 IS
      SELECT data_type NAME,
             COUNT(*) VALUE
      FROM   dba_logstdby_unsupported
      GROUP  BY data_type
      ORDER  BY 1;

  BEGIN
    println2(h1,
             '+- Logical Standby Readiness Assessment -+');

    println2('-',
             'DBA_LOGSTDBY_NOT_UNIQUE');
    FOR myrows IN mycur1 LOOP
      println2('Bad Columns',
               myrows.value);
    END LOOP;

    println2('-',
             'DBA_LOGSTDBY_UNSUPPORTED');
    FOR myrows IN mycur2 LOOP
      println2(myrows.name,
               myrows.value);
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE db_transport_tablespace IS

    CURSOR mycur1 IS
      SELECT data_type NAME,
             to_char(VALUE) || ' --' || decode(data_type,
                                               'XMLTYPE',
                                               '10gR2 EXP/IMP, 11.1+ Datapump',
                                               'BINARY_FLOAT',
                                               'Data Pump',
                                               'BINARY_DOUBLE',
                                               'Data Pump',
                                               'Check target TZ file version') VALUE
      FROM   (SELECT data_type,
                     COUNT(*) VALUE
              FROM   (SELECT DISTINCT o.object_id,
                                      c.data_type
                      FROM   dba_tab_cols c,
                             dba_objects  o
                      WHERE  (c.data_type LIKE '%WITH TIME ZONE' OR
                             c.data_type IN ('XMLTYPE',
                                              'BINARY_FLOAT',
                                              'BINARY_DOUBLE'))
                             AND c.owner = o.owner
                             AND c.table_name = o.object_name
                             AND o.object_type = 'TABLE'
                      GROUP  BY o.object_id,
                                c.data_type)
              GROUP  BY data_type
              ORDER  BY 1);

  BEGIN
    println2(h1,
             '+- Transportable Tablespace Readiness Assessment -+');

    print_vcol('SUM(tablespace_names)',
               'sum(length(tablespace_name))',
               'dba_tablespaces where contents not in (''UNDO'',''TEMPORARY'')');
    print_vcol('Spatial Indexes',
               'to_char(count(*)) || '' --need drop before EXP''',
               'dba_indexes where ityp_name like ''%SPATIAL_INDEX''');

   print_vcol('Recycle Bin gb',
              'round(sum(space)/1024/1024/1024,2) || '' ('' || count(*) || '' objects )''',
              'dba_recyclebin');

    FOR myrows IN mycur1 LOOP
      println2('data-type: ' || myrows.name,
               myrows.value);
    END LOOP;

  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE db_xdb IS

  BEGIN
    println2(h1,
             '+- XDB configuration -+');
    print_db_parameter('dispatchers',
                       'FALSE',
                       'FALSE');
    print_db_parameter('shared_servers',
                       'FALSE',
                       'FALSE');

    print_vcol('XDB FTP Port',
               'to_char(dbms_xdb.getftpport)',
               'dual');
    print_vcol('XDB HTTP Port',
               'to_char(dbms_xdb.gethttpport)',
               'dual');
    print_vcol('XDB Tablespace',
               'DBMS_XDB.GETXDB_TABLESPACE',
               'dual');

    --resource_view does not exist if XDB not installed
    print_vcol('XDB User Resources Guess',
               'to_char(count(*))',
               'resource_view WHERE substr(any_path, 1, instr(any_path, ''/'', 2)) NOT IN (''/sys/'', ''/images/'', ''/xds/'', ''/olap_data_security/'', ''/OLAP_XDS/'')');

    /*
    This package does not exist in 10.2
        BEGIN
          dbms_xdb.getlistenerendpoint(dbms_xdb.xdb_endpoint_http, host, port, protocol);
          dbms_xdb.getlistenerendpoint(dbms_xdb.xdb_endpoint_http, host, port, protocol);
          println2('XDB Endpoint 1', 'Host=' || host || ' Port=' || port || ' Protocol=' || protocol);
          dbms_xdb.getlistenerendpoint(dbms_xdb.xdb_endpoint_http2, host, port, protocol);
          println2('XDB Endpoint 2', 'Host=' || host || ' Port=' || port || ' Protocol=' || protocol);
        EXCEPTION
          WHEN OTHERS THEN
            NULL;
        END;
    */
  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE db_streams IS

    CURSOR cur_capture IS
      SELECT capture_name || '( ' || queue_owner || '.' || queue_name || ')' VALUE FROM dba_capture;
    CURSOR cur_apply IS
      SELECT apply_name || '( ' || queue_owner || '.' || queue_name || ')' VALUE FROM dba_apply;
  BEGIN
    println2(h1,
             '+- Streams configuration -+');
    print_db_parameter('compatible',
                       'FALSE',
                       'FALSE');
    print_db_parameter('global_names',
                       'FALSE',
                       'FALSE');
    print_db_parameter('open_links',
                       'FALSE',
                       'FALSE');
    print_db_parameter('remote_archive_enable',
                       'FALSE',
                       'FALSE');
    print_db_parameter('sga_target',
                       'FALSE',
                       'FALSE');
    print_db_parameter('streams_pool_size',
                       'FALSE',
                       'FALSE');
    print_db_parameter('log_buffer',
                       'FALSE',
                       'FALSE');

    print_vcol('CDC-Source tables',
               'count(*)',
               'dba_source_tables');
    print_vcol('CDC-Change tables',
               'count(*)',
               'all_change_tables');
    print_vcol('CDC-Subscriptions',
               'count(*)',
               'dba_subscriptions');
    print_vcol('CDC-Subscribed Tables',
               'count(*)',
               'dba_subscribed_tables');

    FOR myrows IN cur_capture LOOP
      println2('streams capture',
               myrows.value);
    END LOOP;
    FOR myrows IN cur_apply LOOP
      println2('streams apply',
               myrows.value);
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE db_workflow IS
    CURSOR mycur IS
      SELECT COUNT(*) RESULT
      FROM   dba_tables
      WHERE  table_name IN ('WF_ACTIVITIES',
                            'WF_ACTIVITY_ATTR_VALUES',
                            'WF_ACTIVITY_ATTRIBUTES',
                            'WF_ACTIVITY_TRANSITIONS',
                            'WF_ITEM_ACTIVITY_STATUSES',
                            'WF_ITEM_ACTIVITY_STATUSES_H',
                            'WF_ITEM_ATTRIBUTES',
                            'WF_ITEM_TYPES',
                            'WF_ITEMS',
                            'WF_MESSAGE_ATTRIBUTES',
                            'WF_MESSAGES',
                            'WF_NOTIFICATION_ATTRIBUTES',
                            'WF_NOTIFICATIONS',
                            'WF_PROCESS_ACTIVITIES');
  BEGIN
    println2(h1,
             '+- Workflow configuration -+');

    FOR myrows IN mycur LOOP
      println2('Looking for 13 tables, found',
               myrows.result);
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE db_workspace IS
  BEGIN
    println2(h1,'+- Workspace manager -+');
    print_vdynsql('select name, value from wm_installation');
    print_vdynsql('select ''workspace'', owner||''.''||workspace from dba_workspaces order by 1');
    print_vdynsql('select owner || state, count(*) from DBA_WM_VERSIONED_TABLES group by owner, state order by 1');
  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;


  PROCEDURE db_security IS
    --'AUD$', 'CDB_UNIFIED_AUDIT_TRAIL', 'FGA_LOG$', 'UNIFIED_AUDIT_TRAIL'

    CURSOR mycur1 IS
      SELECT owner || '.' || segment_name value1,
             tablespace_name || '[' || to_char(round(SUM(bytes) / 1024 / 1024,
                                                     2)) || 'mb]' value2
      FROM   dba_extents
      WHERE  owner IN ('SYS',
                       'SYSTEM')
             AND segment_name IN ('AUD$',
                                  'FGA_LOG$')
      GROUP  BY owner || '.' || segment_name,
                tablespace_name;

    CURSOR mycur2 IS
      SELECT owner || '.' || table_name value1
      FROM   dba_tables
      WHERE  owner IN ('SYS',
                       'SYSTEM')
             AND table_name IN ('AUD$',
                                'FGA_LOG$');

  BEGIN
    println2(h1,
             '+- Security configuration -+');

    --audit log size
    FOR myrows IN mycur1 LOOP
      println2(myrows.value1 || ' tablespace',
               myrows.value2);
    END LOOP;
    --audit logs owner
    FOR myrows IN mycur2 LOOP
      print_vcol(myrows.value1 || ' null dbid count',
                 'count(*)',
                 myrows.value1 || ' where dbid is null');
    END LOOP;
    --db vault
    print_vcol('Oracle Database Vault',
               'decode(value,''TRUE'',''is installed'',''is not installed'')',
               'v$option WHERE parameter = ''Oracle Database Vault''');
    print_vcol('Backup Encryption',
               'decode(value,''TRUE'',''is installed'',''is not installed'')',
               'v$option WHERE parameter = ''Backup Encryption''');
    print_vcol('Transparent Data Encryption',
               'decode(value,''TRUE'',''is installed'',''is not installed'')',
               'v$option WHERE parameter = ''Transparent Data Encryption''');
    print_vcol('Oracle Label Security',
               'decode(value,''TRUE'',''is installed'',''is not installed'')',
               'v$option WHERE parameter =''Oracle Label Security''');

    --audit vault agent
    print_vcol('Audit Vault Agent',
               'owner',
               'dba_procedures where object_name = ''AV_TRUNCATE_CLOB'' and object_type = ''FUNCTION''');
    print_vcol('dbms_audit_mgmt installed',
               '''Yes''',
               'dba_objects where object_name = ''DBMS_AUDIT_MGMT'' and object_type = ''PACKAGE''');
    --Encrypted objects
    print_vcol('Encrypted Columns',
               'count(*)',
               'dba_encrypted_columns');
    print_vcol('Encryption wallets',
               'count(*)',
               'v$encryption_wallet');
    print_vcol('Encrypted Tablespace (11g+)',
               'count(*)',
               'dba_tablespaces where encrypted = ''YES''');
    print_vcol('Compressed tablespaces',
               'count(*)',
               'dba_tablespaces where def_tab_compression <> ''DISABLED''');
    print_vcol('Encrypted Backups ',
               'count(*)',
               'V$TABLESPACE where ENCRYPT_IN_BACKUP = ''YES''');

  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

  PROCEDURE db_ogg IS
    --AT=application_table

    PROCEDURE at_nolog_table_count IS
      CURSOR mycur IS
        SELECT COUNT(*) VALUE
        FROM   dba_tables      a,
               dba_tablespaces b
        WHERE  a.tablespace_name = b.tablespace_name
               AND a.logging = 'NO'
               AND b.logging = 'NOLOGGING'
        GROUP  BY a.owner;

    BEGIN

      FOR myrows IN mycur LOOP
        println2('No logging count',
                 myrows.value);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_count IS

      CURSOR mycur IS
        SELECT COUNT(*) VALUE
        FROM   dba_tables,
               (SELECT DISTINCT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) b
        WHERE  owner = b.username;

    BEGIN

      FOR myrows IN mycur LOOP
        println2('Application tables',
                 myrows.value);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_pkuk_missing_count IS

      CURSOR mycur IS
        SELECT COUNT(*) RESULT
        FROM   (SELECT owner,
                       table_name
                FROM   dba_tables,
                       (SELECT a.username
                        FROM   dba_users a,
                               dba_users b
                        WHERE  a.created > (b.created + 1 / 24)
                               AND b.username = 'SYS' &AgentFilter
                        MINUS
                        SELECT DISTINCT SCHEMA
                        FROM   dba_registry) b
                WHERE  owner = b.username
                MINUS
                SELECT owner,
                       table_name
                FROM   dba_constraints,
                       (SELECT a.username
                        FROM   dba_users a,
                               dba_users b
                        WHERE  a.created > (b.created + 1 / 24)
                               AND b.username = 'SYS' &AgentFilter
                        MINUS
                        SELECT DISTINCT SCHEMA
                        FROM   dba_registry) b
                WHERE  owner = b.username
                       AND constraint_type IN ('P',
                                               'U')
                MINUS
                SELECT owner,
                       table_name
                FROM   dba_external_tables) b;

    BEGIN

      FOR myrows IN mycur LOOP
        println2('PKUK missing',
                 myrows.result);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_pk_novalidate_count IS

      CURSOR mycur IS
        SELECT COUNT(*) RESULT
        FROM   dba_constraints,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) b
        WHERE  owner = b.username
               AND constraint_type = 'P'
               AND validated = 'NOT VALIDATED';

    BEGIN

      FOR myrows IN mycur LOOP
        println2('PK novalidate',
                 myrows.result);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_pkukfk_invalid_count IS

      CURSOR mycur IS
        SELECT COUNT(*) RESULT
        FROM   (SELECT owner,
                       table_name
                FROM   dba_constraints,
                       (SELECT a.username
                        FROM   dba_users a,
                               dba_users b
                        WHERE  a.created > (b.created + 1 / 24)
                               AND b.username = 'SYS' &AgentFilter
                        MINUS
                        SELECT DISTINCT SCHEMA
                        FROM   dba_registry) b
                WHERE  owner = b.username
                       AND constraint_type IN ('P',
                                               'U',
                                               'R')
                       AND (invalid = 'INVALID'));

    BEGIN

      FOR myrows IN mycur LOOP
        println2('PKUKFK invalid',
                 myrows.result);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_unused_col_tab_normal_count IS

      CURSOR mycur IS
        SELECT COUNT(*) RESULT
        FROM   dba_unused_col_tabs a,
               dba_tables b,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) c
        WHERE  a.owner = c.username
               AND a.owner = b.owner
               AND a.table_name = b.table_name
               AND b.partitioned = 'NO';

    BEGIN

      FOR myrows IN mycur LOOP
        println2('Unused columns - normal tables',
                 myrows.result);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_hidden_column_count IS

      CURSOR mycur IS
          select count(*) result from dba_tab_cols a,
                       (SELECT a.username
                        FROM   dba_users a,
                               dba_users b
                        WHERE  a.created > (b.created + 1 / 24)
                               AND b.username = 'SYS' &AgentFilter
                        MINUS
                        SELECT DISTINCT SCHEMA
                        FROM   dba_registry) b
                WHERE  owner = b.username
                and a.hidden_column = 'YES';

    BEGIN

      FOR myrows IN mycur LOOP
        println2('Hidden Columns',
                 myrows.result);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_unused_col_tab_part_count IS

      CURSOR mycur IS
        SELECT COUNT(*) RESULT
        FROM   dba_unused_col_tabs a,
               dba_tables b,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) c
        WHERE  a.owner = c.username
               AND a.owner = b.owner
               AND a.table_name = b.table_name
               AND b.partitioned = 'YES';

    BEGIN

      FOR myrows IN mycur LOOP
        println2('Unused columns - partitioned tables',
                 myrows.result);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;


    PROCEDURE at_unsup_data_type_count IS

      CURSOR mycur IS
        SELECT data_type,
               COUNT(*) RESULT
        FROM   dba_tab_cols,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) b
        WHERE  owner = b.username
               AND (data_type IN ('ANYDATA',
                                  'ANYDATASET',
                                  'ANYTYPE',
                                  'BFILE',
                                  'BINARY_INTEGER',
                                  'MLSLABEL',
                                  'ORDDICOM',
                                  'PLS_INTEGER',
                                  'TIMEZONE_ABBR',
                                  'TIMEZONE_REGION',
                                  'URITYPE',
                                  'UROWID') OR data_type LIKE 'INTERVAL%')
        GROUP  BY data_type
        ORDER  BY 1,
                  2;

      bflag CHAR(1) := 'a';
    BEGIN
      FOR myrows IN mycur LOOP
        println2(myrows.data_type,
                 myrows.result);
        bflag := 'z';
      END LOOP;

      IF (bflag = 'a')
      THEN
        println2('Data-types not supported',
                 '0');
      END IF;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_compression_count IS
      CURSOR mycur IS
        SELECT COUNT(*) RESULT
        FROM   dba_tables t,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) b
        WHERE  t.compression = 'ENABLED'
               AND t.owner = b.username;

    BEGIN
      FOR myrows IN mycur LOOP
        println2('Compressed tables',
                 myrows.result);

      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_rowid_count IS
      CURSOR mycur IS
        SELECT COUNT(*) RESULT
        FROM   dba_tab_cols
        WHERE  owner IN (SELECT a.username
                         FROM   dba_users a,
                                dba_users b
                         WHERE  a.created > (b.created + 1 / 24)
                                AND b.username = 'SYS' &AgentFilter
                         MINUS
                         SELECT DISTINCT SCHEMA
                         FROM   dba_registry)
               AND data_type = 'ROWID'
               and table_name != 'CHAINED_ROWS';

    BEGIN
      FOR myrows IN mycur LOOP
        println2('ROWID tables',
                 myrows.result);

      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_one_col_non_scalar_count IS
      CURSOR mycur IS
        SELECT a.data_type,
               COUNT(*) VALUE
        FROM   dba_tab_cols a,
               (SELECT owner,
                       table_name
                FROM   dba_tab_cols,
                       (SELECT a.username
                        FROM   dba_users a,
                               dba_users b
                        WHERE  a.created > (b.created + 1 / 24)
                               AND b.username = 'SYS' &AgentFilter
                        MINUS
                        SELECT DISTINCT SCHEMA
                        FROM   dba_registry) b
                WHERE  owner = b.username
                       AND table_name NOT LIKE 'BIN$%'
                GROUP  BY owner,
                          table_name
                HAVING MAX(column_id) = 1) b
        WHERE  data_type NOT IN ('NUMBER',
                                 'FLOAT',
                                 'CHAR',
                                 'DATE',
                                 'NCHAR',
                                 'VARCHAR2',
                                 'NVARCHAR2')
               AND b.table_name = a.table_name
               AND b.owner = a.owner
        GROUP  BY a.data_type
        ORDER  BY 1;

    BEGIN
      FOR myrows IN mycur LOOP
        println2('One column table: ' || myrows.data_type,
                 myrows.value);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_external_count IS
      CURSOR mycur IS
        SELECT COUNT(*) RESULT FROM dba_external_tables a,(SELECT a.username
                        FROM   dba_users a,
                               dba_users b
                        WHERE  a.created > (b.created + 1 / 24)
                               AND b.username = 'SYS' &AgentFilter
                        MINUS
                        SELECT DISTINCT SCHEMA
                        FROM   dba_registry) b
                        where a.owner = b.username;

    BEGIN
      FOR myrows IN mycur LOOP
        println2('External tables',
                 myrows.result);

      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_udt_count IS
      CURSOR mycur IS
        SELECT COUNT(*) RESULT
        FROM   dba_types,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) b
        WHERE  owner = b.username;

    BEGIN
      FOR myrows IN mycur LOOP
        println2('User defined types',
                 myrows.result);

      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_mv_count IS
      CURSOR mycur IS
        SELECT COUNT(*) RESULT
        FROM   dba_mviews,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) b
        WHERE  owner = b.username;

    BEGIN
      FOR myrows IN mycur LOOP
        println2('Materialised Views',
                 myrows.result);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_xmltype_table_count IS
    BEGIN
      print_vcol('XMLTYPE tables',
                 'count(*)',
                 'dba_xml_tables, (SELECT a.username FROM   dba_users a, dba_users b WHERE  a.created > (b.created + 1 / 24) AND b.username = ''SYS'' MINUS SELECT DISTINCT SCHEMA FROM   dba_registry) b WHERE  owner = b.username');
    END;

    PROCEDURE at_trigger_count IS
      CURSOR mycur IS
        SELECT COUNT(*) RESULT
        FROM   dba_triggers,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) b
        WHERE  owner = b.username;

    BEGIN
      FOR myrows IN mycur LOOP
        println2('Triggers',
                 myrows.result);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_sequence_count IS
      CURSOR mycur IS
        SELECT COUNT(*) RESULT
        FROM   dba_sequences,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) b
        WHERE  sequence_owner = b.username;

    BEGIN
      FOR myrows IN mycur LOOP
        println2('Sequences',
                 myrows.result);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE at_nopkuk_33plus_cols IS
      CURSOR mycur IS
        SELECT COUNT(*) RESULT
        FROM   (SELECT DISTINCT owner,
                                table_name
                FROM   dba_tab_cols,
                       (SELECT a.username
                        FROM   dba_users a,
                               dba_users b
                        WHERE  a.created > (b.created + 1 / 24)
                               AND b.username = 'SYS' &AgentFilter
                        MINUS
                        SELECT DISTINCT SCHEMA
                        FROM   dba_registry) b
                WHERE  column_id >= 33
                       AND owner = b.username
                INTERSECT -- the intersection of schema tables with > 33 columns and tables with no pkuk
                 (SELECT owner,
                        table_name
                 FROM   dba_tables,
                        (SELECT a.username
                         FROM   dba_users a,
                                dba_users b
                         WHERE  a.created > (b.created + 1 / 24)
                                AND b.username = 'SYS' &AgentFilter
                         MINUS
                         SELECT DISTINCT SCHEMA
                         FROM   dba_registry) b
                 WHERE  owner = b.username
                 MINUS
                 SELECT owner,
                        table_name
                 FROM   dba_constraints,
                        (SELECT a.username
                         FROM   dba_users a,
                                dba_users b
                         WHERE  a.created > (b.created + 1 / 24)
                                AND b.username = 'SYS' &AgentFilter
                         MINUS
                         SELECT DISTINCT SCHEMA
                         FROM   dba_registry) b
                 WHERE  owner = b.username
                        AND constraint_type IN ('P',
                                                'U')
                 MINUS
                 SELECT owner,
                        table_name
                 FROM   dba_external_tables));

    BEGIN
      FOR myrows IN mycur LOOP
        println2('Table with 33+ Columns',
                 myrows.result);
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        println2('Caught Exception',
                 SQLERRM);
    END;

    PROCEDURE segment_gb IS
      TYPE longname IS TABLE OF NUMBER INDEX BY VARCHAR2(256);
      segment_size longname;
      RESULT       NUMBER;

      CURSOR mycur_segment_size IS
        SELECT owner || '.' || segment_name SEGMENT,
               SUM(bytes) total_bytes
        FROM   dba_segments a,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) b
        WHERE  a.owner = b.username
        GROUP  BY owner || '.' || segment_name;

      CURSOR mycur_at_pkuk_missing IS
        SELECT owner || '.' || table_name SEGMENT
        FROM   (SELECT owner,
                       table_name
                FROM   dba_tables a,
                       (SELECT a.username
                        FROM   dba_users a,
                               dba_users b
                        WHERE  a.created > (b.created + 1 / 24)
                               AND b.username = 'SYS' &AgentFilter
                        MINUS
                        SELECT DISTINCT SCHEMA
                        FROM   dba_registry) b
                WHERE  a.owner = b.username
                MINUS
                SELECT owner,
                       table_name
                FROM   dba_constraints,
                       (SELECT a.username
                        FROM   dba_users a,
                               dba_users b
                        WHERE  a.created > (b.created + 1 / 24)
                               AND b.username = 'SYS' &AgentFilter
                        MINUS
                        SELECT DISTINCT SCHEMA
                        FROM   dba_registry) b
                WHERE  owner = b.username
                       AND constraint_type IN ('P',
                                               'U')
                MINUS
                SELECT owner,
                       table_name
                FROM   dba_external_tables);

      CURSOR mycur_at_unsup_data_type_gb IS
        SELECT owner || '.' || table_name SEGMENT
        FROM   dba_tab_cols a,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) b
        WHERE  a.owner = b.username
               AND (a.data_type IN ('ANYDATA',
                                    'ANYDATASET',
                                    'ANYTYPE',
                                    'BFILE',
                                    'BINARY_INTEGER',
                                    'MLSLABEL',
                                    'ORDDICOM',
                                    'PLS_INTEGER',
                                    'TIMEZONE_ABBR',
                                    'TIMEZONE_REGION',
                                    'URITYPE',
                                    'UROWID') OR a.data_type LIKE 'INTERVAL%');

      CURSOR mycur_at_compression_gb IS
        SELECT owner || '.' || table_name SEGMENT
        FROM   dba_tables a,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) b
        WHERE  a.compression = 'ENABLED'
               AND a.owner = b.username;

      /*
        09/03/2016 09:57:26 mlh excluded for now - this fails if XDB is not installed

            CURSOR mycur_at_xmltype_table_gb IS
              SELECT owner || '.' || table_name SEGMENT
              FROM   dba_xml_tables a,
                     (SELECT a.username
                      FROM   dba_users a,
                             dba_users b
                      WHERE  a.created > (b.created + 1 / 24)
                             AND b.username = 'SYS' &AgentFilter
                      MINUS
                      SELECT DISTINCT SCHEMA
                      FROM   dba_registry) b
              WHERE  a.owner = b.username;
      */

      CURSOR mycur_at_rowid_gb IS
        SELECT DISTINCT owner || '.' || table_name SEGMENT
        FROM   dba_tab_cols,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) b
        WHERE  owner = b.username
               AND (data_type = 'ROWID');

      CURSOR mycur_at_one_col_non_scalar_gb IS
        SELECT owner || '.' || table_name SEGMENT
        FROM   dba_tab_cols,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) b
        WHERE  data_type NOT IN ('CHAR',
                                 'DATE',
                                 'DECIMAL',
                                 'DOUBLE PRECISION',
                                 'FLOAT',
                                 'FLOAT',
                                 'INTEGER',
                                 'NCHAR',
                                 'NUMBER',
                                 'NUMBER',
                                 'NVARCHAR2',
                                 'RAW',
                                 'REAL',
                                 'VARCHAR2')
               AND owner = b.username
               AND table_name NOT LIKE 'BIN$%'
        GROUP  BY owner,
                  table_name
        HAVING MAX(column_id) = 1;

      CURSOR mycur_at_udt_gb IS
        SELECT DISTINCT a.owner || '.' || a.table_name SEGMENT
        FROM   dba_tab_cols a,
               dba_types b,
               (SELECT a.username
                FROM   dba_users a,
                       dba_users b
                WHERE  a.created > (b.created + 1 / 24)
                       AND b.username = 'SYS' &AgentFilter
                MINUS
                SELECT DISTINCT SCHEMA
                FROM   dba_registry) c
        WHERE  a.data_type = b.type_name
               AND b.owner = c.username
               AND a.owner = c.username;

      CURSOR mycur_at_nolog_table_gb IS
        SELECT DISTINCT owner || '.' || table_name SEGMENT
        FROM   dba_tables      a,
               dba_tablespaces b
        WHERE  a.tablespace_name = b.tablespace_name
               AND a.logging = 'NO'
               AND b.logging = 'NOLOGGING';

      t1_start DATE;

    BEGIN

      t1_start := SYSDATE;
      FOR myrows IN mycur_segment_size LOOP
        segment_size(myrows.segment) := myrows.total_bytes;
      END LOOP;
      println2('@Elapsed Seconds to INIT ',
               round((SYSDATE - t1_start) * 86400,
                     4));

      t1_start := SYSDATE;
      RESULT   := 0;
      FOR myrows IN mycur_at_compression_gb LOOP
        BEGIN
          RESULT := RESULT + segment_size(myrows.segment);
        EXCEPTION
          WHEN OTHERS THEN
            --exception can occur when a schema.table does not have a segment, so catch and ignore because segment size = 0
            NULL;
        END;
      END LOOP;
      println2('Compressed gb',
               TRIM(to_char(RESULT / gb,
                            nf)) || ' @Elapsed Seconds ' || round((SYSDATE - t1_start) * 86400,
                                                                  4));

      t1_start := SYSDATE;
      RESULT   := 0;
      FOR myrows IN mycur_at_nolog_table_gb LOOP
        BEGIN
          RESULT := RESULT + segment_size(myrows.segment);
        EXCEPTION
          WHEN OTHERS THEN
            --exception can occur when a schema.table does not have a segment, so catch and ignore because segment size = 0
            NULL;
        END;
      END LOOP;
      println2('Non log tables [ts+tab] gb',
               TRIM(to_char(RESULT / gb,
                            nf)) || ' @Elapsed Seconds ' || round((SYSDATE - t1_start) * 86400,
                                                                  4));

      RESULT := 0;
      FOR myrows IN mycur_at_one_col_non_scalar_gb LOOP
        BEGIN
          RESULT := RESULT + segment_size(myrows.segment);
        EXCEPTION
          WHEN OTHERS THEN
            --exception can occur when a schema.table does not have a segment, so catch and ignore because segment size = 0
            NULL;
        END;
      END LOOP;
      println2('One column non-scalar gb',
               TRIM(to_char(RESULT / gb,
                            nf)) || ' @Elapsed Seconds ' || round((SYSDATE - t1_start) * 86400,
                                                                  4));

      t1_start := SYSDATE;
      RESULT   := 0;
      FOR myrows IN mycur_at_pkuk_missing LOOP
        BEGIN
          RESULT := RESULT + segment_size(myrows.segment);
        EXCEPTION
          WHEN OTHERS THEN
            --exception can occur when a schema.table does not have a segment, so catch and ignore because segment size = 0
            NULL;
        END;
      END LOOP;
      println2('PKUK missing gb',
               TRIM(to_char(RESULT / gb,
                            nf)) || ' @Elapsed Seconds ' || round((SYSDATE - t1_start) * 86400,
                                                                  4));

      t1_start := SYSDATE;
      RESULT   := 0;
      FOR myrows IN mycur_at_rowid_gb LOOP
        BEGIN
          RESULT := RESULT + segment_size(myrows.segment);
        EXCEPTION
          WHEN OTHERS THEN
            --exception can occur when a schema.table does not have a segment, so catch and ignore because segment size = 0
            NULL;
        END;
      END LOOP;
      println2('ROWID gb',
               TRIM(to_char(RESULT / gb,
                            nf)) || ' @Elapsed Seconds ' || round((SYSDATE - t1_start) * 86400,
                                                                  4));

      t1_start := SYSDATE;
      RESULT   := 0;
      FOR myrows IN mycur_at_udt_gb LOOP
        BEGIN
          RESULT := RESULT + segment_size(myrows.segment);
        EXCEPTION
          WHEN OTHERS THEN
            --exception can occur when a schema.table does not have a segment, so catch and ignore because segment size = 0
            NULL;
        END;
      END LOOP;
      println2('UDT gb',
               TRIM(to_char(RESULT / gb,
                            nf)) || ' @Elapsed Seconds ' || round((SYSDATE - t1_start) * 86400,
                                                                  4));

      t1_start := SYSDATE;
      RESULT   := 0;
      FOR myrows IN mycur_at_unsup_data_type_gb LOOP
        BEGIN
          RESULT := RESULT + segment_size(myrows.segment);
        EXCEPTION
          WHEN OTHERS THEN
            --exception can occur when a schema.table does not have a segment, so catch and ignore because segment size = 0
            NULL;
        END;
      END LOOP;
      println2('Unsupported data-type gb',
               TRIM(to_char(RESULT / gb,
                            nf)) || ' @Elapsed Seconds ' || round((SYSDATE - t1_start) * 86400,
                                                                  4));

      /*
      09/03/2016 09:58:49 mlh excluded - cursor fails if XDB not installed

            t1_start := SYSDATE;
            RESULT   := 0;
            FOR myrows IN mycur_at_xmltype_table_gb LOOP
              BEGIN
                RESULT := RESULT + segment_size(myrows.segment);
              EXCEPTION
                WHEN OTHERS THEN
                  --exception can occur when a schema.table does not have a segment, so catch and ignore because segment size = 0
                  NULL;
              END;
            END LOOP;
            println2('XMLTYPE table gb', TRIM(to_char(RESULT / gb, nf)) || ' @Elapsed Seconds ' ||
                      round((SYSDATE - t1_start) * 86400, 4));
      */

    END;
  BEGIN
    println2(h1,
             '+- GoldenGate high level review-+');

    print_db_parameter('enable_goldengate_replication',
                       'FALSE',
                       'FALSE');
    --Application Table - counts
    at_count;
    at_compression_count;
    at_external_count;
    at_mv_count;
    at_nolog_table_count;
    at_nopkuk_33plus_cols;
    at_one_col_non_scalar_count;
    at_pkukfk_invalid_count;
    at_pk_novalidate_count;
    at_unused_col_tab_normal_count;
    at_unused_col_tab_part_count;
    at_hidden_column_count;
    at_rowid_count;
    at_sequence_count;
    at_trigger_count;
    at_udt_count;
    at_unsup_data_type_count;
    at_xmltype_table_count;

    --Application Table - gigabytes
    IF (skip = 0)
    THEN
      segment_gb;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      println2('Caught Exception',
               SQLERRM);
  END;

BEGIN
  --SQL executed immediate to handle legacy database versions that do not support specific queries, mostly affecting: 8i, 9i
  t1_start := SYSDATE;

  print_start();

  --println2('Parameter', 'Value');

  t2_start := SYSDATE;
  db;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_characters;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_files;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_segments;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_registry_size;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  asm;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  cdb;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_logging;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_config;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_security;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_rac;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_dg;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_logical_standby;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_transport_tablespace;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_streams;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_xdb;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_workflow;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_workspace;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t2_start := SYSDATE;
  db_ogg;
  println2('@Elapsed Seconds',
           round((SYSDATE - t2_start) * 86400,
                 4));

  t1_stop := SYSDATE;

  --println2(h1, h1);
  println2(h2,
           h2);
  println2('@Elapsed run time',
           to_char(t1_start,
                   'dd-mon-yyyy hh24:mi:ss') || ' -> ' ||
           to_char(t1_stop,
                   'hh24:mi:ss') || ', ' || to_char(round((t1_stop - t1_start) * 86400,
                                                          4)) || ' seconds');
  println2(h2,
           h2);

  print_stop();
EXCEPTION
  WHEN OTHERS THEN
    println2('Caught Exception',
             SQLERRM);
END;
/


set markup HTML ON

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_archive_analysis_for_1_month">Database archive analysis for 1 month</h2>

prompt
prompt Archive log hourly megabyte statistical analysis for each destination - for the last 3 month
prompt

SELECT dest_id, thehour hr, round(MIN(mb)) MIN, round(MAX(mb)) MAX, round(AVG(mb)) average, round(STDDEV(mb)) STDDEV
FROM   (SELECT dest_id, to_number(to_char(completion_time, 'hh24')) thehour, SUM(blocks * block_size) / 1024 / 1024 mb
         FROM   v$archived_log
         where (completion_time > add_months(sysdate,-3))
         GROUP  BY dest_id, trunc(SYSDATE) - trunc(completion_time), to_char(completion_time, 'hh24'))
GROUP  BY dest_id, thehour
ORDER  BY dest_id, thehour;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_archive_analysis_for_3_months">Database archive analysis for 3 months</h2>

prompt
prompt Sample of average archive log generation for: 1 month, 3 months, 3 months Monday - Friday and 3 months Saturday - Sunday
prompt


SELECT m3.dest_id, m3.hr, nvl(m1.average, 0) "1-Month-avg", m3.average "3-Month-avg", nvl(m3m2f.average, 0) "3-Month-avg-weekday", nvl(m3s2s.average,
            0) "3-Month-avg-weekend"
FROM   (SELECT dest_id, thehour hr, round(AVG(mb)) average
         FROM   (SELECT dest_id, to_number(to_char(completion_time, 'hh24')) thehour, SUM(blocks * block_size) / 1024 / 1024 mb
                  FROM   v$archived_log
                  WHERE  (completion_time > add_months(SYSDATE, -1))
                  GROUP  BY dest_id, trunc(SYSDATE) - trunc(completion_time), to_char(completion_time, 'hh24'))
         GROUP  BY dest_id, thehour) m1, (SELECT dest_id, thehour hr, round(AVG(mb)) average
         FROM   (SELECT dest_id, to_number(to_char(completion_time, 'hh24')) thehour, SUM(blocks *
                              block_size) / 1024 / 1024 mb
                  FROM   v$archived_log
                  WHERE  (completion_time > add_months(SYSDATE, -3))
                  GROUP  BY dest_id, trunc(SYSDATE) - trunc(completion_time), to_char(completion_time,
                                     'hh24'))
         GROUP  BY dest_id, thehour) m3, (SELECT dest_id, thehour hr, round(AVG(mb)) average
         FROM   (SELECT dest_id, to_number(to_char(completion_time, 'hh24')) thehour, SUM(blocks *
                              block_size) / 1024 / 1024 mb
                  FROM   v$archived_log
                  WHERE  (completion_time > add_months(SYSDATE, -3))
                         AND to_number(to_char(completion_time, 'D')) < 6
                  GROUP  BY dest_id, trunc(SYSDATE) - trunc(completion_time), to_char(completion_time,
                                     'hh24'))
         GROUP  BY dest_id, thehour) m3m2f, (SELECT dest_id, thehour hr, round(AVG(mb)) average
         FROM   (SELECT dest_id, to_number(to_char(completion_time, 'hh24')) thehour, SUM(blocks *
                              block_size) / 1024 / 1024 mb
                  FROM   v$archived_log
                  WHERE  (completion_time > add_months(SYSDATE, -3))
                         AND to_number(to_char(completion_time, 'D')) > 5
                  GROUP  BY dest_id, trunc(SYSDATE) - trunc(completion_time), to_char(completion_time,
                                     'hh24'))
         GROUP  BY dest_id, thehour) m3s2s
WHERE  m3.dest_id = m1.dest_id(+)
       AND m3.dest_id = m3m2f.dest_id(+)
       AND m3.dest_id = m3s2s.dest_id(+)
       AND m3.hr = m1.hr(+)
       AND m3.hr = m3m2f.hr(+)
       AND m3.hr = m3s2s.hr(+)
order by 1,2;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_statistics_Review">Database statistics Review</h2>

prompt
prompt The database needs statistics gathered against the system, database dictionary, database fixed views, database components and your database application schema, this information can then be used to optimise the use of CPU and disk access.
Prompt

DECLARE

  /*
      function create_plsql_table ( pstrings )

      name         ^ data-type ^ default value
      YR_0         ^ NUMBER    ^ 0
      YR_1         ^ NUMBER    ^ 0
      YR_2         ^ NUMBER    ^ 0
      YR_3         ^ NUMBER    ^ 0
      YR_4         ^ NUMBER    ^ 0
      NOT_GATHERED ^ NUMBER    ^ 0
  */

  TYPE t_seg_rec IS RECORD(
    owner        dba_users.username%TYPE,
    flag         CHAR(1) := '0',
    yr_0         NUMBER := 0,
    yr_1         NUMBER := 0,
    yr_2         NUMBER := 0,
    yr_3         NUMBER := 0,
    yr_4         NUMBER := 0,
    not_gathered NUMBER := 0);

  TYPE t_seg_tab IS TABLE OF t_seg_rec INDEX BY dba_segments.owner%TYPE;
  seg_tab t_seg_tab;

  CURSOR mycur IS
    SELECT owner,
           nvl(to_char(comparison, 'yyyy'), 'n') comparison,
           icount
    FROM   (SELECT ' Dictionary' owner,
                   last_analyzed comparison,
                   COUNT(*) icount
            FROM   dba_tables
            WHERE  owner = 'SYS'
            GROUP  BY last_analyzed
            UNION
            SELECT ' Fixed objects' owner,
                   last_analyzed comparison,
                   COUNT(*) icount
            FROM   dba_tab_statistics
            WHERE  owner = 'SYS'
                   AND table_name LIKE 'X$%'
            GROUP  BY last_analyzed
            UNION
            SELECT ' Components' owner,
                   last_analyzed comparison,
                   COUNT(*) icount
            FROM   dba_tables a
            WHERE  owner IN (SELECT DISTINCT SCHEMA FROM dba_registry WHERE SCHEMA != 'SYS')
            GROUP  BY last_analyzed
            UNION
            SELECT ' Gather stat runs' owner,
                   log_date comparison,
                   COUNT(*) icount
            FROM   dba_scheduler_job_run_details
            WHERE  job_name = 'GATHER_STATS_JOB'
            GROUP  BY status,
                      log_date
            UNION
            SELECT owner,
                   last_analyzed comparison,
                   COUNT(*) icount
            FROM   dba_tables a
            WHERE  owner IN (SELECT a.username
                             FROM   dba_users a,
                                    dba_users b
                             WHERE  a.created > (b.created + 1 / 24)
                                    AND b.username = 'SYS' &AgentFilter
                             MINUS
                             SELECT DISTINCT SCHEMA
                             FROM   dba_registry)
            GROUP  BY owner,
                      last_analyzed);

  s dba_segments.owner%TYPE;
  t dba_segments.owner%TYPE;

  iyear NUMBER;

  syr_0 VARCHAR2(5);
  syr_1 VARCHAR2(5);
  syr_2 VARCHAR2(5);
  syr_3 VARCHAR2(5);
  syr_4 VARCHAR2(5);

  PROCEDURE print IS
    s dba_segments.owner%TYPE;
    --t dba_segments.owner%TYPE;

    rp     NUMBER := 13;
    itotal NUMBER;
    wip    NUMBER;

  BEGIN
    dbms_output.enable(1000000);

    dbms_output.put(rpad('owner', 25) || ',');
    dbms_output.put(lpad(syr_0, rp) || ',');
    dbms_output.put(lpad(syr_1, rp) || ',');
    dbms_output.put(lpad(syr_2, rp) || ',');
    dbms_output.put(lpad(syr_3, rp) || ',');
    dbms_output.put(lpad(syr_4, rp) || ',');
    dbms_output.put_line(lpad(' NOT_GATHERED', rp));

    dbms_output.put(rpad('-', 25, '-') || ',');
    FOR wip IN 1 .. 5 LOOP
      dbms_output.put(lpad('-', rp, '-') || ',');
    END LOOP;
    dbms_output.put_line(lpad('-', rp, '-'));

    s := seg_tab.first;
    --t := seg_tab.last;

    LOOP
      EXIT WHEN s IS NULL;

      IF ( (seg_tab(s).yr_0 + seg_tab(s).yr_1 + seg_tab(s).yr_2 + seg_tab(s).yr_3 + seg_tab(s).yr_4  + seg_tab(s).not_gathered ) > 0) THEN
        dbms_output.put(rpad(s, 25) || ',');
        dbms_output.put(lpad(seg_tab(s).yr_0, rp) || ',');
        dbms_output.put(lpad(seg_tab(s).yr_1, rp) || ',');
        dbms_output.put(lpad(seg_tab(s).yr_2, rp) || ',');
        dbms_output.put(lpad(seg_tab(s).yr_3, rp) || ',');
        dbms_output.put(lpad(seg_tab(s).yr_4, rp) || ',');
        dbms_output.put_line(lpad(seg_tab(s).not_gathered, rp));
      END IF;
      s := seg_tab.next(s);

    END LOOP;

  END;

BEGIN

  iyear := to_number(to_char(SYSDATE, 'yyyy'));
  syr_0 := to_char(iyear);
  syr_1 := to_char(iyear - 1);
  syr_2 := to_char(iyear - 2);
  syr_3 := to_char(iyear - 3);
  syr_4 := to_char(iyear - 4);

  t := '_Totals';
  seg_tab(t).flag := '1';

  FOR myrows IN mycur LOOP
    s := myrows.owner;
    seg_tab(s).flag := '1';
    CASE myrows.comparison
      WHEN syr_0 THEN
        seg_tab(s).yr_0 := seg_tab(s).yr_0 + myrows.icount;
        seg_tab(t).yr_0 := seg_tab(t).yr_0 + myrows.icount;
      WHEN syr_1 THEN
        seg_tab(s).yr_1 := seg_tab(s).yr_1 + myrows.icount;
        seg_tab(t).yr_1 := seg_tab(t).yr_1 + myrows.icount;
      WHEN syr_2 THEN
        seg_tab(s).yr_2 := seg_tab(s).yr_2 + myrows.icount;
        seg_tab(t).yr_2 := seg_tab(t).yr_2 + myrows.icount;
      WHEN syr_3 THEN
        seg_tab(s).yr_3 := seg_tab(s).yr_3 + myrows.icount;
        seg_tab(t).yr_3 := seg_tab(t).yr_3 + myrows.icount;
      WHEN syr_4 THEN
        seg_tab(s).yr_4 := seg_tab(s).yr_4 + myrows.icount;
        seg_tab(t).yr_4 := seg_tab(t).yr_4 + myrows.icount;
      WHEN 'n' THEN
        seg_tab(s).not_gathered := seg_tab(s).not_gathered + myrows.icount;
        seg_tab(t).not_gathered := seg_tab(t).not_gathered + myrows.icount;
      ELSE
        NULL;
    END CASE;

  END LOOP;

  print;

END;
/

prompt

Prompt System Statistics generated by "exec dbms_stats.gather_system_stats();"

SELECT * FROM sys.aux_stats$;

prompt

Prompt System Statistics calculated for comparison


SELECT pname,
       pval1,
       calculated,
       formula
FROM   sys.aux_stats$
WHERE  sname = 'SYSSTATS_MAIN' model reference sga ON (SELECT NAME,
               VALUE
        FROM   v$sga) dimension BY(NAME) measures(VALUE) reference parameter ON
 (SELECT NAME,
               decode(TYPE, 3, to_number(VALUE)) VALUE
        FROM   v$parameter
        WHERE  NAME = 'db_file_multiblock_read_count'
               AND ismodified != 'FALSE'
        UNION ALL
        SELECT NAME,
               decode(TYPE, 3, to_number(VALUE)) VALUE
        FROM   v$parameter
        WHERE  NAME = 'sessions'
        UNION ALL
        SELECT NAME,
               decode(TYPE, 3, to_number(VALUE)) VALUE
        FROM   v$parameter
        WHERE  NAME = 'db_block_size') dimension BY(NAME) measures(VALUE) PARTITION BY(sname) dimension BY(pname)
 measures(pval1, pval2, CAST(NULL AS NUMBER) AS calculated, CAST(NULL AS VARCHAR2(60)) AS formula)
 rules(calculated [ 'MBRC' ] = coalesce(pval1 [ 'MBRC' ], parameter.value [ 'db_file_multiblock_read_count' ], parameter.value [
                           '_db_file_optimizer_read_count' ], 8), calculated [ 'MREADTIM'
              ] =
              coalesce(pval1 [ 'MREADTIM' ], pval1 [ 'IOSEEKTIM'
                        ] + (parameter.value [
                         'db_block_size'
                         ] * calculated [
                         'MBRC' ]) / pval1 [
                        'IOTFRSPEED' ]), calculated [ 'SREADTIM'
              ] = coalesce(pval1 [ 'SREADTIM' ], pval1 [ 'IOSEEKTIM' ] + parameter.value [
                            'db_block_size' ] / pval1 [ 'IOTFRSPEED' ]), calculated [ '   multi block Cost per block'
              ] =
              round(1 / calculated [ 'MBRC' ] * calculated [
                    'MREADTIM' ] / calculated [ 'SREADTIM' ], 4), calculated [ '   single block Cost per block' ] = 1, formula [
              'MBRC'
              ] = CASE
                WHEN pval1 [ 'MBRC' ] IS NOT NULL THEN
                 'MBRC'
                WHEN parameter.value [ 'db_file_multiblock_read_count' ] IS NOT NULL THEN
                 'db_file_multiblock_read_count'
                WHEN parameter.value [ '_db_file_optimizer_read_count' ] IS NOT NULL THEN
                 '_db_file_optimizer_read_count'
                ELSE
                 '= _db_file_optimizer_read_count'
              END, formula [ 'MREADTIM' ] = CASE
                WHEN pval1 [ 'MREADTIM' ] IS NULL THEN
                 '= IOSEEKTIM + db_block_size * MBRC / IOTFRSPEED'
              END, formula [ 'SREADTIM' ] = CASE
                WHEN pval1 [ 'SREADTIM' ] IS NULL THEN
                 '= IOSEEKTIM + db_block_size        / IOTFRSPEED'
              END, formula [ '   multi block Cost per block' ] = '= 1/MBRC * MREADTIM/SREADTIM', formula [
              '   single block Cost per block'
              ] = 'by definition', calculated [ '   maximum mbrc' ] = sga.value [ 'Database Buffers'
              ] / (parameter.value [ 'db_block_size' ] * parameter.value [ 'sessions' ]), formula [ '   maximum mbrc' ] =
              '= buffer cache size in blocks / sessions');


prompt

Prompt Gather statistics job

column job_name format A20
column window_group_name format A20
column window_name format A20
column repeat_interval format A100

select distinct
                job_name,
                window_group_name,
                window_name,
                repeat_interval,
                duration,
                --next_start_date,
                --last_start_date,
                enabled,
                active
 from
(
SELECT DISTINCT c.job_name,
                a.window_group_name,
                a.window_name,
                b.repeat_interval,
                b.duration,
                b.next_start_date,
                b.last_start_date,
                b.enabled,
                b.active
FROM   dba_scheduler_wingroup_members a,
       dba_scheduler_windows          b,
       dba_scheduler_jobs             c
WHERE  a.window_name = b.window_name
       AND (c.schedule_name = a.window_group_name OR c.schedule_name = b.window_name)
       AND c.job_name = 'GATHER_STATS_JOB'
UNION
SELECT 'auto_task',
       a.window_group_name,
       a.window_name,
       b.repeat_interval,
       b.duration,
       b.next_start_date,
       b.last_start_date,
       b.enabled,
       b.active
FROM   dba_scheduler_wingroup_members a,
       dba_scheduler_windows          b
WHERE  (a.window_group_name = 'MAINTENANCE_WINDOW_GROUP' OR a.window_group_name LIKE 'ORA$AT_WGRP%')
       AND a.window_name = b.window_name
)
ORDER  BY 2,
          3;


prompt
Prompt 11g+ Automated Maintenance Task Operation Configuration
prompt

column CLIENT_NAME format a20
column OPERATION_NAME format a20
column OPERATION_TAG format a20
column PRIORITY_OVERRIDE format a20
column ATTRIBUTES format a20
column USE_RESOURCE_ESTIMATES format a20
column STATUS format a20

select * from DBA_AUTOTASK_OPERATION;

prompt
Prompt The list of tables and/or table partitions that have manually locked statistics or have defined extensions
prompt

SELECT a.owner,
       a.table_name,
       a.partition_name,
       a.SUBPARTITION_NAME,
       a.stattype_locked,
       a.user_stats,
       c.EXTENSION_NAME,
       c.extension
  FROM dba_tab_statistics a,
       (SELECT a.username
          FROM dba_users a,
               dba_users b
         WHERE a.created > (b.created + 1 / 24)
           AND b.username = 'SYS' &AgentFilter
        MINUS
        SELECT DISTINCT SCHEMA
          FROM dba_registry) b,
       dba_stat_extensions c
 WHERE a.owner = b.username
   AND a.owner = c.owner
   AND a.table_name = c.table_name

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_parameters_Review">Database parameters Review</h2>

prompt
prompt These are parameters you have configured in your database that are deprecated or obsoleted.
prompt Deprecated parameters are supported but a warning will be written to the alert log as the database is started.  Obsoleted parameters have been removed from the database and the historic functionality of which has been removed.  You should also receive a warning in the alert log but the database should still start.
prompt

DECLARE

  /*
      function create_plsql_table ( pstrings )

      NAME              ^ DATA-TYPE             ^ DEFAULT VALUE

      PARAMETER_NAME    ^ V$PARAMETER.NAME%TYPE  ^ NULL
      VERSION           ^ VARCHAR2(20)           ^ NULL
      EVENT             ^ VARCHAR2(20)           ^ NULL
      NEW_NAME          ^ V$PARAMETER.NAME%TYPE  ^ NULL
      FOUND             ^ BOOLEAN                ^ FALSE
      CURRENT_VALUE     ^ V$PARAMETER_VALUE%TYPE ^ NULL
  */

  TYPE t_seg_rec IS RECORD(
    flag           CHAR(1) := '0',
    parameter_name v$parameter.name%TYPE := NULL,
    version        VARCHAR2(20) := NULL,
    event          VARCHAR2(20) := NULL,
    new_name       v$parameter.name%TYPE := NULL,
    FOUND          BOOLEAN := FALSE,
    current_value  v$parameter.value%TYPE := NULL);

  TYPE t_seg_tab IS TABLE OF t_seg_rec INDEX BY v$parameter.name%TYPE;
  seg_tab t_seg_tab;

  CURSOR mycur IS
    SELECT NAME,
           VALUE
    FROM   v$parameter
    WHERE  isdefault = 'FALSE';

  s v$parameter.name%TYPE;
  t v$parameter.name%TYPE;

  PROCEDURE param_store(pname     VARCHAR2,
                        pversion  VARCHAR2,
                        pevent    VARCHAR2,
                        pnew_name VARCHAR2) IS
  BEGIN
    seg_tab(pname).flag := '1';
    seg_tab(pname).parameter_name := pname;
    seg_tab(pname).version := pversion;

    CASE pevent
      WHEN 'd' THEN
        seg_tab(pname).event := 'Deprecated';
      WHEN 'o' THEN
        seg_tab(pname).event := 'Obsoleted';
      WHEN 'r' THEN
        seg_tab(pname).event := 'Renamed';
      ELSE
        seg_tab(pname).event := '?';
    END CASE;

    seg_tab(pname).new_name := nvl(pnew_name, ' ');
  EXCEPTION
    WHEN OTHERS THEN
      dbms_output.put_line(pname);
  END;

  PROCEDURE print IS
    s v$parameter.name%TYPE;
    --t dba_segments.owner%TYPE;

    rp     NUMBER := 13;
    itotal NUMBER;
    wip    NUMBER;

  BEGIN
    dbms_output.enable(1000000);

    dbms_output.put(lpad('PARAMETER_NAME', 45) || ',');
    dbms_output.put(lpad('VERSION', rp) || ',');
    dbms_output.put(lpad('EVENT', rp) || ',');
    dbms_output.put(lpad('NEW_NAME', 45) || ',');
    dbms_output.put_line(lpad('CURRENT_VALUE', rp));

    dbms_output.put(rpad('-', 45, '-') || ',');
    dbms_output.put(rpad('-', rp, '-') || ',');
    dbms_output.put(rpad('-', rp, '-') || ',');
    dbms_output.put(rpad('-', 45, '-') || ',');
    dbms_output.put_line(rpad('-', rp, '-'));

    s := seg_tab.first;

    LOOP
      EXIT WHEN s IS NULL;

      IF (seg_tab(s).found) THEN
        dbms_output.put(lpad(seg_tab(s).parameter_name, 45) || ',');
        dbms_output.put(lpad(seg_tab(s).version, rp) || ',');
        dbms_output.put(lpad(seg_tab(s).event, rp) || ',');
        dbms_output.put(lpad(seg_tab(s).new_name, 45) || ',');
        dbms_output.put_line(seg_tab(s).current_value);
      END IF;

      s := seg_tab.next(s);

    END LOOP;

  END;

BEGIN

  param_store('_average_dirties_half_life', '10.1', 'd', NULL);
  param_store('_compatible_no_recovery', '10.1', 'd', NULL);
  param_store('_db_no_mount_lock', '10.1', 'd', NULL);
  param_store('_fast_start_instance_recover_target', '11.1', 'o', NULL);
  param_store('_lm_direct_sends', '10.1', 'd', NULL);
  param_store('_lm_multiple_receivers', '10.1', 'd', NULL);
  param_store('_lm_rcv_buffer_size', '11.1', 'o', NULL);
  param_store('_lm_statistics', '10.1', 'd', NULL);
  param_store('_lm_validate_resource_type', '12.1', 'd', NULL);
  param_store('_log_archive_buffer_size', '11.1', 'o', NULL);
  param_store('_oracle_trace_events', '10.1', 'd', NULL);
  param_store('_oracle_trace_facility_version', '10.1', 'd', NULL);
  param_store('_seq_process_cache_const', '10.1', 'd', NULL);
  param_store('active_instance_count', '11.2', 'd', NULL);
  param_store('allow_partial_sn_results', '8.1', 'o', NULL);
  param_store('always_anti_join', '9.0.1', 'o', NULL);
  param_store('always_semi_join', '9.0.1', 'o', NULL);
  param_store('arch_io_slaves', '8.1', 'o', NULL);
  param_store('async_read', '8.0', 'r', 'disk_asynch_io');
  param_store('async_write', '8.0', 'r', 'disk_asynch_io');
  param_store('b_tree_bitmap_plans', '8.1', 'o', NULL);
  param_store('background_dump_dest', '11.1', 'd', NULL);
  param_store('backup_disk_io_slaves', '8.1', 'o', NULL);
  param_store('buffer_pool_keep', '11.2', 'r', 'db_keep_cache_size');
  param_store('buffer_pool_recycle', '11.2', 'r', 'db_recycle_cache_size');
  param_store('cache_size_threshold', '8.1', 'o', NULL);
  param_store('ccf_io_size', '8.0', 'r', 'db_file_direct_io_count');
  param_store('cell_partition_large_extents', '11.2', 'o', NULL);
  param_store('checkpoint_process', '8.0', 'o', NULL);
  param_store('cleanup_rollback_entries', '8.1', 'o', NULL);
  param_store('close_cached_open_cursors', '8.1', 'o', NULL);
  param_store('commit_write', '11.1', 'd', NULL);
  param_store('commit_write', '11.2', 'r', 'commit_logging and commit_wait');
  param_store('complex_view_merging', '8.1', 'o', NULL);
  param_store('cursor_space_for_time', '11.1', 'd', NULL);
  param_store('cursor_space_for_time', '11.2', 'd', NULL);
  param_store('db_block_checkpoint_batch', '8.1', 'o', NULL);
  param_store('db_block_lru_extended_statistics', '8.1', 'o', NULL);
  param_store('db_block_lru_latches', '9.0.1', 'o', NULL);
  param_store('db_block_lru_statistics', '8.1', 'o', NULL);
  param_store('db_block_max_dirty_target', '9.0.1', 'o', NULL);
  param_store('db_file_simultaneous_writes', '8.1', 'o', NULL);
  param_store('db_file_standby_name_convert', '8.0', 'r', 'db_file_name_convert');
  param_store('db_writers', '8.0', 'r', 'dbwr_io_slaves');
  param_store('dblink_encrypt_login', '10.1', 'o', NULL);
  param_store('ddl_wait_for_locks', '11.1', 'o', NULL);
  param_store('delayed_logging_block_cleanouts', '8.1', 'o', NULL);
  param_store('discrete_transactions_enabled', '8.1', 'o', NULL);
  param_store('distributed_recovery_connection_hold_time', '8.1', 'o', NULL);
  param_store('distributed_transactions', '9.2', 'o', NULL);
  param_store('drs_start', '11.2', 'o', NULL);
  param_store('drs_start', '9.2', 'r', 'dg_broker_start');
  param_store('enqueue_resources', '10.2', 'o', NULL);
  param_store('ent_domain_name', '8.1', 'o', NULL);
  param_store('fast_cache_flush', '8.0', 'o', NULL);
  param_store('fast_full_scan_enabled', '8.1', 'o', NULL);
  param_store('fast_start_io_target', '11.2', 'd', NULL);
  param_store('fast_start_io_target', '9.0.1', 'r', 'fast_start_mttr_target');
  param_store('freeze_DB_for_fast_instance_recovery', '8.1', 'o', NULL);
  param_store('gc_db_locks', '8.0', 'o', NULL);
  param_store('gc_defer_time', '9.0.1', 'o', NULL);
  param_store('gc_files_to_locks', '11.2', 'o', NULL);
  param_store('gc_freelist_groups', '8.0', 'o', NULL);
  param_store('gc_latches', '8.1', 'o', NULL);
  param_store('gc_lck_procs', '8.1', 'o', NULL);
  param_store('gc_releasable_locks', '9.0.1', 'o', NULL);
  param_store('gc_rollback_locks', '9.0.1', 'o', NULL);
  param_store('gc_rollback_segments', '8.0', 'o', NULL);
  param_store('gc_save_rollback_locks', '8.0', 'o', NULL);
  param_store('gc_segments', '8.0', 'o', NULL);
  param_store('gc_tablespaces', '8.0', 'o', NULL);
  param_store('global_context_pool_size', '10.1', 'd', NULL);
  param_store('global_context_pool_size', '11.2', 'd', NULL);
  param_store('hash_join_enabled', '10.1', 'o', NULL);
  param_store('hash_multiblock_io_count', '9.0.1', 'o', NULL);
  param_store('init_sql_files', '8.0', 'o', NULL);
  param_store('instance_groups', '11.1', 'd', NULL);
  param_store('instance_groups', '11.2', 'd', NULL);
  param_store('instance_nodeset', '9.0.1', 'o', NULL);
  param_store('io_timeout', '8.0', 'o', NULL);
  param_store('ipq_address', '8.0', 'o', NULL);
  param_store('ipq_net', '8.0', 'o', NULL);
  param_store('job_queue_interval', '9.0.1', 'o', NULL);
  param_store('job_queue_keep_connections', '8.1', 'o', NULL);
  param_store('large_pool_min_alloc', '8.1', 'o', NULL);
  param_store('lgwr_io_slaves', '8.1', 'o', NULL);
  param_store('lm_domains', '8.0', 'o', NULL);
  param_store('lm_locks', '8.1', 'o', NULL);
  param_store('lm_non_fault_tolerant', '8.0', 'o', NULL);
  param_store('lm_procs', '8.1', 'o', NULL);
  param_store('lm_ress', '8.1', 'o', NULL);
  param_store('lock_name_space', '10.1', 'r', 'db_unique_name');
  param_store('lock_name_space', '11.2', 'd', NULL);
  param_store('lock_sga_areas', '8.1', 'o', NULL);
  param_store('log_archive_buffer_size', '8.1', 'o', NULL);
  param_store('log_archive_buffers', '8.1', 'o', NULL);
  param_store('log_archive_local_first', '11.1', 'd', NULL);
  param_store('log_archive_local_first', '11.2', 'd', NULL);
  param_store('log_archive_start', '10.1', 'd', NULL);
  param_store('log_block_checksum', '8.1', 'o', NULL);
  param_store('log_file_standby_name_convert', '8.0', 'r', 'log_file_name_convert');
  param_store('log_files', '8.1', 'o', NULL);
  param_store('log_parallelism', '10.1', 'o', NULL);
  param_store('log_simultaneous_copies', '8.1', 'o', NULL);
  param_store('log_small_entry_max_size', '8.1', 'o', NULL);
  param_store('logmnr_max_persistent_sessions', '10.2', 'd', NULL);
  param_store('max_commit_propagation_delay', '10.2', 'd', NULL);
  param_store('max_commit_propagation_delay', '11.2', 'd', NULL);
  param_store('max_enabled_roles', '10.1', 'd', NULL);
  param_store('max_rollback_segments', '10.1', 'o', NULL);
  param_store('max_transaction_branches', '9.2', 'o', NULL);
  param_store('mls_label_format', '8.0', 'o', NULL);
  param_store('mts_circuits', '9.0.1', 'r', 'circuits');
  param_store('mts_dispatchers', '9.0.1', 'r', 'dispatchers');
  param_store('mts_listener_address', '10.1', 'o', NULL);
  param_store('mts_max_dispatchers', '9.0.1', 'r', 'max_dispatchers');
  param_store('mts_max_servers', '9.0.1', 'r', 'max_shared_servers');
  param_store('mts_multiple_listeners', '10.1', 'o', NULL);
  param_store('mts_rate_log_size', '8.1', 'o', NULL);
  param_store('mts_rate_scale', '8.1', 'o', NULL);
  param_store('mts_servers', '9.0.1', 'r', 'shared_servers');
  param_store('mts_service', '10.1', 'o', NULL);
  param_store('mts_sessions', '9.0.1', 'r', 'shared_server_sessions');
  param_store('mview_rewrite_enabled', '8.1.4', 'r', 'query_rewrite_enabled');
  param_store('nls_union_currency', '8.1.5', 'r', 'nls_dual_currency');
  param_store('ogms_home', '8.1', 'o', NULL);
  param_store('ops_admin_group', '8.1', 'o', NULL);
  param_store('ops_interconnects', '9.0.1', 'o', NULL);
  param_store('optimizer_max_permutations', '10.1', 'o', NULL);
  param_store('optimizer_parallel_pass', '8.0', 'o', NULL);
  param_store('optimizer_percent_parallel', '9.0.1', 'o', NULL);
  param_store('optimizer_search_limit', '8.1', 'o', NULL);
  param_store('oracle_trace_collection_name', '10.1', 'o', NULL);
  param_store('oracle_trace_collection_path', '10.1', 'o', NULL);
  param_store('oracle_trace_collection_size', '10.1', 'o', NULL);
  param_store('oracle_trace_enable', '10.1', 'o', NULL);
  param_store('oracle_trace_facility_name', '10.1', 'o', NULL);
  param_store('oracle_trace_facility_path', '10.1', 'o', NULL);
  param_store('parallel_automatic_tuning', '10.1', 'd', NULL);
  param_store('parallel_automatic_tuning', '11.2', 'd', NULL);
  param_store('parallel_broadcast_enabled', '9.2', 'o', NULL);
  param_store('parallel_default_max_instances', '8.1', 'o', NULL);
  param_store('parallel_default_max_scans', '8.0', 'o', NULL);
  param_store('parallel_default_scan_size', '8.0', 'o', NULL);
  param_store('parallel_io_cap_enabled', '11.2', 'd', NULL);
  param_store('parallel_min_message_pool', '8.1', 'o', NULL);
  param_store('parallel_server', '9.0.1', 'r', 'cluster_database');
  param_store('parallel_server_idle_time', '8.1', 'o', NULL);
  param_store('parallel_server_instances', '9.0.1', 'r', 'cluster_database_instances');
  param_store('parallel_transaction_recovery', '8.1.5', 'r', 'fast_start_parallel_rollback');
  param_store('parallel_transaction_resource_timeout', '8.1', 'o', NULL);
  param_store('partition_view_enabled', '10.1', 'o', NULL);
  param_store('plsql_native_c_compiler', '10.1', 'o', NULL);
  param_store('plsql_native_library_dir', '11.2', 'o', NULL);
  param_store('plsql_native_library_subdir_count', '11.2', 'o', NULL);
  param_store('plsql_native_linker', '10.1', 'o', NULL);
  param_store('plsql_native_make_file_name', '10.1', 'o', NULL);
  param_store('plsql_native_make_utility', '10.1', 'o', NULL);
  param_store('plsql_v2_compatibility', '11.1', 'd', NULL);
  param_store('post_wait_device', '8.0', 'o', NULL);
  param_store('push_join_predicate', '8.1', 'o', NULL);
  param_store('reduce_alarm', '8.1', 'o', NULL);
  param_store('remote_archive_enable', '10.2', 'd', NULL);
  param_store('remote_archive_enable', '11.1', 'o', NULL);
  param_store('remote_os_authent', '11.1', 'd', NULL);
  param_store('resource_manager_cpu_allocation', '11.2', 'd', NULL);
  param_store('rewrite_integrity', '8.1.4', 'r', 'query_rewrite_integrity');
  param_store('row_cache_cursors', '8.1', 'o', NULL);
  param_store('row_locking', '10.1', 'o', NULL);
  param_store('sec_case_sensitive_logon', '12.1', 'd', NULL);
  param_store('sequence_cache_entries', '8.1', 'o', NULL);
  param_store('sequence_cache_hash_buckets', '8.0', 'o', NULL);
  param_store('sequence_cache_hash_buckets', '8.1', 'o', NULL);
  param_store('serial_reuse', '10.2', 'd', NULL);
  param_store('serial_reuse', '11.2', 'd', NULL);
  param_store('serializable', '10.1', 'o', NULL);
  param_store('shared_pool_reserved_min_alloc', '8.1', 'o', NULL);
  param_store('snapshot_refresh_interval', '8.0', 'r', 'job_queue_interval');
  param_store('snapshot_refresh_interval', '8.1', 'o', NULL);
  param_store('snapshot_refresh_keep_connections', '8.1', 'o', NULL);
  param_store('snapshot_refresh_processes', '8.1', 'o', NULL);
  param_store('sort_direct_writes', '8.1', 'o', NULL);
  param_store('sort_multiblock_read_count', '9.0.1', 'o', NULL);
  param_store('sort_read_fac', '8.1', 'o', NULL);
  param_store('sort_spacemap_size', '8.1', 'o', NULL);
  param_store('sort_write_buffer_size', '8.1', 'o', NULL);
  param_store('sort_write_buffers', '8.1', 'o', NULL);
  param_store('spin_count', '8.1', 'o', NULL);
  param_store('sql_trace', '10.2', 'd', NULL);
  param_store('sql_version', '11.1', 'd', NULL);
  param_store('sql_version', '11.2', 'o', NULL);
  param_store('standby_archive_dest', '11.1', 'd', NULL);
  param_store('standby_preserves_names', '9.2', 'o', NULL);
  param_store('temporary_table_locks', '8.1', 'o', NULL);
  param_store('text_enable', '9.0.1', 'o', NULL);
  param_store('transaction_auditing', '10.1', 'o', NULL);
  param_store('undo_suppress_errors', '10.1', 'o', NULL);
  param_store('unlimited_rollback_segments', '8.0', 'o', NULL);
  param_store('use_ism', '8.1', 'o', NULL);
  param_store('use_readv', '8.0', 'o', NULL);
  param_store('use_sigio', '8.0', 'o', NULL);
  param_store('user_dump_dest', '11.1', 'd', NULL);
  param_store('v733_plans_enabled', '8.0', 'o', NULL);

  FOR myrows IN mycur LOOP
    IF (seg_tab.exists(myrows.name)) THEN
      seg_tab(myrows.name).found := TRUE;
      seg_tab(myrows.name).current_value := myrows.value;
    END IF;
  END LOOP;

  print;

END;
/

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_feature_usage">Database feature usage</h2>


prompt
prompt This is the list of features known database features and whether they have been consumed at any  point in the database life.  For a database migration it makes a lot of sense to understand which features may need to be enabled at the target database, and to identify which features are currently used but not compatible with our short list of anticipated migration techniques.
prompt

SELECT currently_used,
       NAME,
       version,
       detected_usages,
       description
  FROM dba_feature_usage_statistics
 WHERE dbid = (SELECT dbid FROM v$database)
   and detected_usages > 0
 ORDER BY currently_used  DESC,
          detected_usages desc,
          currently_used  desc,
          NAME;

Prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_resource_Limit">Database resource Limit</h2>

prompt
prompt Displays information about global resource use for some of the system resources. Use this view to monitor the consumption of resources so that you can take corrective action, if necessary. Many of the resources correspond to initialization parameters
prompt

select * from v$resource_limit order by 1;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_links">Database links</h2>

prompt

select owner, host from all_db_links;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_top_50_hot_tables">Database top 50 hot tables</h2>

prompt
prompt Tables with monitoring enabled (see dba_tables) are updated regularly with the DML activity counts and cleared out with each dbms_stat.gather* activity which generally means the figures are representative of one full 24 hours period at most.
prompt

exec dbms_stats.flush_database_monitoring_info;

prompt
prompt  Working out the daily_inserts, daily_updates and daily_deletes is difficult because large high transaction rate tables sometimes do not have any statistics gathered on them, and so the dba_tables last_analyzed column is null.  Often there are a lot of tables with a NULL values for the last_analyzed column which can cause the selector for the TOP 50 tables to be inaccurate.  To work around this, when the last_analyzed column is null, I have substituted the dba_tables.create date.  This may not be an accurate approach, but it seems like a good approximation for calculating the daily change rate.
prompt

SELECT owner,
       table_name,
       lobcols,
       stamp,
       round(stampdays) stampdays,
       total_inserts,
       total_updates,
       total_deletes,
       round(daily_inserts) daily_inserts,
       round(daily_updates) daily_updates,
       round(daily_deletes) daily_deletes,
       truncated
  FROM (SELECT owner,
               table_name,
               lobcols,
               stamp,
               stampdays,
               total_inserts,
               total_updates,
               total_deletes,
               daily_inserts,
               daily_updates,
               daily_deletes,
               truncated
          FROM (SELECT owner,
                       table_name,
                       lobcols,
                       stamp,
                       stampdays,
                       total_inserts,
                       total_updates,
                       total_deletes,
                       total_inserts / stampdays daily_inserts,
                       total_updates / stampdays daily_updates,
                       total_deletes / stampdays daily_deletes,
                       truncated
                  FROM (SELECT t.owner,
                               t.table_name,
                               nvl(t.last_analyzed, o.created) stamp,
                               SYSDATE - nvl(t.last_analyzed, o.created) stampdays,
                               sum(a.inserts) total_inserts,
                               sum(a.updates) total_updates,
                               sum(a.deletes) total_deletes,
                               a.truncated,
                               nvl(c.lobcols, 0) lobcols
                          FROM dba_tab_modifications a,
                               dba_tables t,
                               dba_objects o,
                               (SELECT owner,
                                       table_name,
                                       COUNT(*) LOBCOLS
                                  FROM dba_tab_cols
                                 WHERE data_type IN ('CLOB', 'BLOB', 'LOB', 'NCLOB', 'LONG')
                                   AND owner NOT IN ('SYS')
                                 GROUP BY OWNER,
                                          TABLE_NAME) c
                         WHERE a.table_owner = t.owner
                           AND a.table_owner = o.owner
                           AND a.table_owner = c.owner(+)
                           AND a.table_name = t.table_name
                           AND a.table_name = o.object_name
                           AND a.TABLE_NAME = c.table_name(+)
                           AND o.object_type = 'TABLE'
                           AND a.table_owner <> 'SYS'
                         GROUP BY t.owner,
                                  t.table_name,
                                  nvl(t.last_analyzed, o.created),
                                  SYSDATE - nvl(t.last_analyzed, o.created),
                                  a.truncated,
                                  c.lobcols))
         ORDER BY (daily_inserts + daily_updates + daily_deletes) DESC)
 WHERE ROWNUM < 51;


prompt

prompt The list of 50 tables with the most physical writes
prompt

SELECT *
FROM   (SELECT a.owner, a.object_name, a.object_type, b.statistic_name, b.value
         FROM   dba_objects a, v$segstat b
         WHERE  b.statistic_name IN ('physical writes', 'physical writes direct')
                AND a.object_id = b.obj#
                AND b.value > 0
         ORDER  BY VALUE DESC)
WHERE  rownum < 51;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_components_installed">Database components installed</h2>


prompt

select version, comp_name from dba_registry order by 1,2;

prompt

select
 TO_CHAR(action_time, 'YYYY-MM-DD') AS action_time,
 ID,
 ACTION,
 VERSION,
 COMMENTS,
 BUNDLE_SERIES
from sys.registry$history
order by action_time,id;

prompt
prompt 12c CDB_REGISTRY_SQLPATCH
prompt

select
 CON_ID,
 TO_CHAR(action_time, 'YYYY-MM-DD') AS action_time,
 PATCH_ID,
 ACTION,
 VERSION,
 DESCRIPTION
  from CDB_REGISTRY_SQLPATCH
order by CON_ID, action_time, patch_id;

prompt
prompt 18c CDB_REGISTRY_SQLPATCH
prompt

select CON_ID,
      TO_CHAR(action_time, 'YYYY-MM-DD') AS action_time,
      PATCH_ID,
      PATCH_TYPE,
      ACTION,
      DESCRIPTION,
      SOURCE_VERSION,
      TARGET_VERSION
 from CDB_REGISTRY_SQLPATCH
order by CON_ID, action_time, patch_id;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_streams_Replication">Database streams Replication</h2>

prompt
prompt Oracle 12c deprecated Streams replication which means there will be no further development of Streams.  You should now start planning to use another replication technology such as Oracle GoldenGate.
prompt There are a number of known problems to consider during your migration planning 1. Streams cannot propagate ANYDATA messages that encapsulate payloads of object types, varrays, or nested tables between databases with different character sets. 2. Change Data Capture (CDC) is desupported and removed from Oracle 12c.
prompt

Prompt Change Data Capture Publishers

select * from DBA_PROPAGATION

prompt

Prompt Change Data Capture Publishers

select * from DBA_SUBSCRIPTIONS;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_XDB">Database XDB</h2>


prompt
prompt This is an earlier iteration to find documents stored in XDB which is difficult because documents can actually be stored anywhere.  However, the following result set should return a list of document paths along with a count of the number of resources under each path.  Specifically, a resource can be a folder or a file, however it looks like an empty folder is not included in this result set.
prompt

SELECT COUNT(*) resources,
    substr(any_path, 1, instr(any_path, '/', -1)) path
FROM   resource_view
WHERE  substr(any_path, 1, instr(any_path, '/', 2)) NOT IN
       ('/sys/', '/images/', '/xds/', '/olap_data_security/', '/OLAP_XDS/')
GROUP  BY substr(any_path, 1, instr(any_path, '/', -1))
ORDER  BY 1,2;

prompt
prompt This is the list of XMLTYPE tables as in "CREATE TABLE schema.table OF XMLTYPE".
prompt
prompt GoldenGate only supports XMLTYPE tables (dba_xml_tables) starting in version 11.2.1, and then XMLType stored in XDB can be captured by extract in integrated capture mode, but not in classic capture mode.
prompt
prompt If you cannot use integrated extract, then any tables of this type will have to be excluded from replication and carried over to the target during the live migration outage window.
prompt

select owner, table_name, storage_type, element_name  from dba_xml_tables order by 1,2;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_real_application_testing">Database real application testing</h2>

prompt
prompt Real Application Testing database replay capture should not be active during GoldenGate replication.
prompt

prompt
prompt Is real application testing installed
prompt

select parameter, value from v$option where parameter = 'Real Application Testing';

prompt

prompt
prompt Has the real application testing feature been used before?
prompt

SELECT NAME,
       version,
       detected_usages,
       currently_used,
       description
FROM   dba_feature_usage_statistics
WHERE  dbid = (SELECT dbid FROM v$database)
       AND NAME LIKE '%Replay%'
ORDER  BY detected_usages DESC,
          currently_used  DESC,
          NAME;

prompt


prompt
prompt Are there any recent workload captures or replays?
prompt

select name, dbname, dbversion, directory, start_time, end_time from dba_workload_captures;

prompt

select name, dbname, dbversion, directory, prepare_time, start_time, end_time from dba_workload_replays;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_logical_standby">Database logical standby</h2>

prompt
prompt A logical standby database can be used to perform a rolling database upgrade either by adding a logical standby to the infrastructure or by temporarily converting a physical standby to a logical during a transient logical standby upgrade.  Equally, we choose to replatform and upgrade the database using Data Guard to reduce our outage window.
prompt

--Prompt DBA_LOGSTDBY_NOT_UNIQUE displays all tables that have no primary and no non-null unique indexes.
--select * from DBA_LOGSTDBY_NOT_UNIQUE where bad_column = 'Y';

prompt
Prompt DBA_LOGSTDBY_UNSUPPORTED displays the schemas, tables, and columns in those tables that contain unsupported datatypes.
prompt

select distinct owner, table_name, nvl(attributes,data_type) from dba_logstdby_unsupported order by 1,2;

Prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_tablespace_usage">Database tablespace usage</h2>

prompt
Prompt Tablespace sizing and usage
prompt

SELECT f.tablespace_name,
       f.status,
       f.autoextensible,
       round(f.bytes / 1024 / 1024) used_mb,
       round((f.maxbytes - f.bytes) / 1024 / 1024) free_mb,
       round(f.maxbytes / 1024 / 1024) max_mb,
       f.increment_by * t.block_size / 1024 / 1024 increment_mb,
       f.file_name
FROM (SELECT tablespace_name,
             file_name,
             status,
             autoextensible,
             bytes,
             maxbytes,
             increment_by
      FROM dba_data_files
      UNION
      SELECT tablespace_name,
             file_name,
             status,
             autoextensible,
             bytes,
             maxbytes,
             increment_by
      FROM dba_temp_files) f,
     dba_tablespaces t
WHERE f.tablespace_name = t.tablespace_name
ORDER BY tablespace_name;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_level_triggers">Database level triggers</h2>

prompt
prompt User defined database level triggers are often missed during the initial analysis of the database migration, however these triggers often form an important part of the database security model.
prompt

SELECT
        status,
        owner,
       base_object_type,
       triggering_event,
       trigger_name
  FROM dba_triggers
 WHERE base_object_type NOT IN ('VIEW', 'TABLE')
 ORDER BY status DESC,
          owner, base_object_type, triggering_event, trigger_name
          ;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Database_network_access_In/Out">Database network access In/Out</h2>

prompt
prompt Network Access information
prompt

prompt
prompt The access control list assignments to network hosts.
prompt

SELECT * FROM dba_network_acls;

prompt
prompt The network privileges defined in all access control lists that are currently assigned to network hosts.
prompt

SELECT * FROM dba_network_acl_privileges;

prompt
prompt Shared Server dispatchers
prompt

SELECT * FROM v$dispatcher_config;

prompt
prompt Shared Servers
prompt

SELECT * FROM v$shared_server_monitor;

prompt
prompt Database Resident Connection Pooling (DRCP)
prompt

SELECT * FROM dba_cpool_info;

select * from v$cpool_stats;

select * from v$cpool_cc_stats;

prompt EXECUTE DBMS_CONNECTION_POOL.START_POOL('SYS_DEFAULT_CONNECTION_POOL');
prompt ezconnect -> IP:PORT/SERVICE_NAME:POOLED
prompt tnsalias -> (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=myhost)(PORT=port))(CONNECT_DATA=(SERVICE_NAME=service_name)(SERVER=POOLED)))
prompt requires local_listener to register against 1521 (default) or no default
prompt EXECUTE DBMS_CONNECTION_POOL.STOP_POOL();
prompt
prompt EXECUTE DBMS_CONNECTION_POOL.ALTER_PARAM ('','MINSIZE','10');
prompt EXECUTE DBMS_CONNECTION_POOL.ALTER_PARAM ('','MAX_USE_SESSION','30');
prompt EXECUTE DBMS_CONNECTION_POOL.ALTER_PARAM ('','MAXCONN_CBROK','50000');
prompt cat /etc/security/limits.conf
prompt test_user HARD NOFILE 50000
prompt EXECUTE DBMS_CONNECTION_POOL.RESTORE_DEFAULTS();
prompt DRCP restart automatically after a database shutdown/startup

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="SQL_stability_-_outlines">SQL stability - outlines</h2>

prompt
prompt Database outlines - deprecated from 12c forwards.  Datapump expdp does not export the OUTLN schema tables from 12c onwards.  You can use classic export tooling, but this is not installed in a 12c database home.
prompt

select NAME,
       OWNER,
       CATEGORY,
       USED,
       TIMESTAMP,
       VERSION,
       COMPATIBLE,
       ENABLED,
       FORMAT,
       MIGRATED
  FROM dba_outlines
 where rownum < 51;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="SQL_stability_-_baselines">SQL stability - baselines</h2>

prompt
prompt SQL plan baselines (See the SQL baseline spfile settings above)
prompt

select SQL_HANDLE,
       PLAN_NAME,
       ORIGIN,
       substr(DESCRIPTION, 1, 100) description,
       VERSION,
       CREATED,
       LAST_MODIFIED,
       LAST_EXECUTED,
       LAST_VERIFIED,
       ENABLED,
       ACCEPTED,
       FIXED,
       REPRODUCED,
       AUTOPURGE,
       OPTIMIZER_COST,
       MODULE,
       ACTION,
       EXECUTIONS
  from dba_sql_plan_baselines
 where rownum < 51;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="SQL_stability_-_plan_management">SQL stability - plan management</h2>

prompt
prompt SQL plan management configuration
prompt

SELECT parameter_name,
       parameter_value
  FROM dba_sql_management_config
 where rownum < 51;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="SQL_stability_-_profiles">SQL stability - profiles</h2>

prompt
prompt SQL profiles
prompt

select NAME,
       CATEGORY,
       SIGNATURE,
       SQL_TEXT,
       CREATED,
       LAST_MODIFIED,
       DESCRIPTION,
       TYPE,
       STATUS,
       FORCE_MATCHING
  FROM dba_sql_profiles
 where rownum < 51;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="SQL_stability_-_tuning_statistics">SQL stability - tuning statistics</h2>

prompt
prompt SQL tuning statistics
prompt

select TASK_ID,
       OBJECT_ID,
       PARSING_SCHEMA_ID,
       MODULE,
       ACTION,
       ELAPSED_TIME,
       CPU_TIME,
       BUFFER_GETS,
       DISK_READS,
       DIRECT_WRITES,
       ROWS_PROCESSED,
       FETCHES,
       EXECUTIONS,
       END_OF_FETCH_COUNT,
       OPTIMIZER_COST,
       COMMAND_TYPE
  FROM dba_sqltune_statistics
 where rownum < 51;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_AQ_Review">Schema AQ Review</h2>

prompt Investigation into the advanced queue tables and views.

prompt

SELECT a.owner, a.queue_table, a.object_type, b.name queue_name, b.queue_type, a.compatible, a.owner_instance
FROM   dba_queue_tables a, dba_queues b
WHERE  a.owner IN (SELECT a.username
                   FROM   dba_users a, dba_users b
                   WHERE  a.created > (b.created + 1 / 24)
                          AND b.username = 'SYS' &AgentFilter
                   MINUS
                   SELECT DISTINCT SCHEMA
                   FROM   dba_registry)
       AND a.owner = b.owner
       AND a.queue_table = b.queue_table
ORDER  BY 1, 2;

prompt


prompt Review of the AQ table types
prompt


SELECT attr_type_name, owner, type_name, attr_name
FROM   dba_type_attrs
WHERE  owner || '.' || type_name IN (SELECT object_type
                                     FROM   dba_queue_tables
                                     WHERE  owner IN (SELECT a.username
                                                      FROM   dba_users a, dba_users b
                                                      WHERE  a.created > (b.created + 1 / 24)
                                                             AND b.username = 'SYS' &AgentFilter
                                                      MINUS
                                                      SELECT DISTINCT SCHEMA
                                                      FROM   dba_registry))
ORDER  BY 1,2,3,4;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_LOB_review">Schema LOB review</h2>
prompt
prompt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prompt .s2:  Schema LOB review
prompt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prompt

prompt LOB segments generally incur a lot of network round trips and I/O so it may be interesting to get an peek into any
prompt potential special treatments.
prompt

DECLARE

  /*
      name     ^ data-type ^ default value
      LONG     ^ NUMBER    ^ 0
      CLOB     ^ NUMBER    ^ 0
      BLOB     ^ NUMBER    ^ 0
      ROWID    ^ NUMBER    ^ 0
      XMLTYPE  ^ NUMBER    ^ 0
      LONG_RAW ^ NUMBER    ^ 0
      NCLOB    ^ NUMBER    ^ 0
      BFILE    ^ NUMBER    ^ 0
      UROWID   ^ NUMBER    ^ 0
  */

  TYPE t_seg_rec IS RECORD(
    owner    dba_users.username%TYPE,
    flag     CHAR(1) := '0',
    LONG     NUMBER := 0,
    CLOB     NUMBER := 0,
    BLOB     NUMBER := 0,
    ROWID    NUMBER := 0,
    xmltype  NUMBER := 0,
    long_raw NUMBER := 0,
    NCLOB    NUMBER := 0,
    BFILE    NUMBER := 0,
    UROWID   NUMBER := 0,

    long_gb     NUMBER := 0,
    clob_gb     NUMBER := 0,
    blob_gb     NUMBER := 0,
    xmltype_gb  NUMBER := 0,
    long_raw_gb NUMBER := 0,
    nclob_gb    NUMBER := 0

    );

  TYPE t_seg_tab IS TABLE OF t_seg_rec INDEX BY dba_segments.owner%TYPE;
  seg_tab t_seg_tab;

  CURSOR mycur_1 IS
    SELECT owner,
           data_type comparison,
           COUNT(*) icount
    FROM   dba_tab_columns
    WHERE  (data_type IN ('CLOB', 'BLOB', 'LONG', 'LONG RAW', 'NCLOB', 'XMLTYPE', 'BFILE', 'UROWID', 'ROWID') OR
           data_type LIKE '%with timezone')
    GROUP  BY owner,
              data_type;

  CURSOR mycur_2 IS
    SELECT a.owner,
           b.data_type comparison,
           round(SUM(c.bytes) / 1024 / 1024 / 1024, 2) gb
    FROM   dba_tab_columns b,
           dba_segments    c,
           dba_lobs        a
    WHERE  c.segment_type = 'LOBSEGMENT'
           AND a.owner != 'SYS'
           AND b.owner != 'SYS'
           AND (b.data_type IN ('CLOB', 'BLOB', 'LONG', 'LONG RAW', 'NCLOB', 'XMLTYPE', 'BFILE', 'UROWID', 'ROWID') OR
           b.data_type LIKE '%with timezone')
           AND a.owner = b.owner
           AND a.table_name = b.table_name
           AND a.column_name = b.column_name
           AND a.owner = c.owner
           AND a.segment_name = c.segment_name
    GROUP  BY a.owner,
              b.data_type;

  s dba_segments.owner%TYPE;
  t dba_segments.owner%TYPE;

  PROCEDURE print IS
    s dba_segments.owner%TYPE;
    --t dba_segments.owner%TYPE;

    rp     NUMBER := 12;
    itotal NUMBER;
    wip    NUMBER;

    PROCEDURE p1(p1    VARCHAR2,
                 width NUMBER,
                 eofl  BOOLEAN) IS
    BEGIN
      IF (eofl) THEN
        dbms_output.put_line(lpad(p1, width));
      ELSE
        dbms_output.put_line(lpad(p1, width) || ',');
      END IF;

    END;

    PROCEDURE print_p1(p1    VARCHAR2,
                       width NUMBER,
                       eofl  BOOLEAN) IS
    BEGIN
      IF (eofl) THEN
        dbms_output.put_line(lpad(p1, width));
      ELSE
        dbms_output.put(lpad(p1, width) || ',');
      END IF;

    END;

    PROCEDURE print_p2(p1    NUMBER,
                       p2    NUMBER,
                       width NUMBER,
                       eofl  BOOLEAN) IS
    BEGIN
      IF (eofl) THEN
        dbms_output.put_line(lpad(to_char(p1) || ' ' || to_char(p2), width));
      ELSE
        dbms_output.put(lpad(to_char(p1) || ' ' || to_char(p2), width) || ',');
      END IF;

    END;

  BEGIN
    dbms_output.enable(1000000);

    print_p1('Column 1 is count of data-type', 30, TRUE);
    print_p1('Column 2 is sum of gigabytes', 28, TRUE);
    --dbms_output.put(rpad('owner', 25) || ',');
    print_p1('owner', 25, FALSE);
    print_p1(' LONG', rp, FALSE);
    print_p1(' CLOB', rp, FALSE);
    print_p1(' BLOB', rp, FALSE);
    print_p1(' ROWID', rp, FALSE);
    print_p1(' XMLTYPE', rp, FALSE);
    print_p1(' LONG_RAW', rp, FALSE);
    print_p1(' NCLOB', rp, FALSE);
    print_p1(' BFILE', rp, FALSE);
    print_p1(' UROWID', rp, TRUE);

    print_p1('-', 25, FALSE);
    FOR wip IN 1 .. 8 LOOP
      print_p1('-', rp, FALSE);
    END LOOP;
    print_p1('-', rp, TRUE);

    s := seg_tab.first;
    --t := seg_tab.last;

    LOOP
      EXIT WHEN s IS NULL;

      print_p1(s, 25, FALSE);
      print_p2(seg_tab(s).long, seg_tab(s).long_gb, rp, FALSE);
      print_p2(seg_tab(s).clob, seg_tab(s).clob_gb, rp, FALSE);
      print_p2(seg_tab(s).blob, seg_tab(s).blob_gb, rp, FALSE);
      print_p2(seg_tab(s).rowid, 0, rp, FALSE);
      print_p2(seg_tab(s).xmltype, seg_tab(s).xmltype_gb, rp, FALSE);
      print_p2(seg_tab(s).long_raw, seg_tab(s).long_raw_gb, rp, FALSE);
      print_p2(seg_tab(s).nclob, seg_tab(s).nclob_gb, rp, FALSE);
      print_p2(seg_tab(s).bfile, 0, rp, FALSE);
      print_p2(seg_tab(s).urowid, 0, rp, TRUE);

      s := seg_tab.next(s);

    END LOOP;

  END;

BEGIN

  t := '_Totals';
  seg_tab(t).flag := '1';

  FOR myrows IN mycur_1 LOOP
    s := myrows.owner;
    seg_tab(s).flag := '1';

    CASE myrows.comparison
      WHEN 'LONG' THEN
        seg_tab(s).long := seg_tab(s).long + myrows.icount;
        seg_tab(t).long := seg_tab(t).long + myrows.icount;
      WHEN 'CLOB' THEN
        seg_tab(s).clob := seg_tab(s).clob + myrows.icount;
        seg_tab(t).clob := seg_tab(t).clob + myrows.icount;
      WHEN 'BLOB' THEN
        seg_tab(s).blob := seg_tab(s).blob + myrows.icount;
        seg_tab(t).blob := seg_tab(t).blob + myrows.icount;
      WHEN 'ROWID' THEN
        seg_tab(s).rowid := seg_tab(s).rowid + myrows.icount;
        seg_tab(t).rowid := seg_tab(t).rowid + myrows.icount;
      WHEN 'XMLTYPE' THEN
        seg_tab(s).xmltype := seg_tab(s).xmltype + myrows.icount;
        seg_tab(t).xmltype := seg_tab(t).xmltype + myrows.icount;
      WHEN 'LONG_RAW' THEN
        seg_tab(s).long_raw := seg_tab(s).long_raw + myrows.icount;
        seg_tab(t).long_raw := seg_tab(t).long_raw + myrows.icount;
      WHEN 'NCLOB' THEN
        seg_tab(s).nclob := seg_tab(s).nclob + myrows.icount;
        seg_tab(t).nclob := seg_tab(t).nclob + myrows.icount;
      WHEN 'BFILE' THEN
        seg_tab(s).bfile := seg_tab(s).bfile + myrows.icount;
        seg_tab(t).bfile := seg_tab(t).bfile + myrows.icount;
      WHEN 'UROWID' THEN
        seg_tab(s).urowid := seg_tab(s).urowid + myrows.icount;
        seg_tab(t).urowid := seg_tab(t).urowid + myrows.icount;
      ELSE
        NULL;
    END CASE;

  END LOOP;

  FOR myrows IN mycur_2 LOOP
    s := myrows.owner;
    seg_tab(s).flag := '1';

    CASE myrows.comparison
      WHEN 'LONG' THEN
        seg_tab(s).long_gb := seg_tab(s).long_gb + myrows.gb;
        seg_tab(t).long_gb := seg_tab(t).long_gb + myrows.gb;
      WHEN 'CLOB' THEN
        seg_tab(s).clob_gb := seg_tab(s).clob_gb + myrows.gb;
        seg_tab(t).clob_gb := seg_tab(t).clob_gb + myrows.gb;
      WHEN 'BLOB' THEN
        seg_tab(s).blob_gb := seg_tab(s).blob_gb + myrows.gb;
        seg_tab(t).blob_gb := seg_tab(t).blob_gb + myrows.gb;
      WHEN 'XMLTYPE' THEN
        seg_tab(s).xmltype_gb := seg_tab(s).xmltype_gb + myrows.gb;
        seg_tab(t).xmltype_gb := seg_tab(t).xmltype_gb + myrows.gb;
      WHEN 'LONG_RAW' THEN
        seg_tab(s).long_raw_gb := seg_tab(s).long_raw_gb + myrows.gb;
        seg_tab(t).long_raw_gb := seg_tab(t).long_raw_gb + myrows.gb;
      WHEN 'NCLOB' THEN
        seg_tab(s).nclob_gb := seg_tab(s).nclob_gb + myrows.gb;
        seg_tab(t).nclob_gb := seg_tab(t).nclob_gb + myrows.gb;
      ELSE
        NULL;
    END CASE;

  END LOOP;

  print;

END;
/

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_object_count">Schema object count</h2>
prompt
prompt This table is a count of the primary object types for each schema
prompt


COLUMN owner FORMAT a19 HEADING "Owner"
COLUMN tables FORMAT 999,999 HEADING "Tables"
COLUMN index FORMAT 999,999 HEADING "Indexes"
COLUMN view FORMAT 999,999 HEADING "Views"
COLUMN MV FORMAT 999,999 HEADING "MV"
COLUMN sequence FORMAT 999,999 HEADING "Sequences"
COLUMN synonym FORMAT 999,999 HEADING "Synonyms"
COLUMN cluster FORMAT 999,999 HEADING "Clusters"
COLUMN procedure FORMAT 999,999 HEADING "Procedures"
COLUMN package FORMAT 999,999 HEADING "Packages"
COLUMN package_body FORMAT 999,999 HEADING "Pack-Bodies"
COLUMN db_link FORMAT 999,999 HEADING "DB-Links"
COLUMN trig FORMAT 999,999 HEADING "Triggers"
COLUMN total FORMAT 999,999 HEADING "Totals"

COMPUTE SUM OF TABLES ON REPORT
COMPUTE SUM OF index ON REPORT
COMPUTE SUM OF view ON REPORT
COMPUTE SUM OF MV ON REPORT
COMPUTE SUM OF sequence ON REPORT
COMPUTE SUM OF synonym ON REPORT
COMPUTE SUM OF cluster ON REPORT
COMPUTE SUM OF procedure ON REPORT
COMPUTE SUM OF package ON REPORT
COMPUTE SUM OF package_body ON REPORT
COMPUTE SUM OF db_link ON REPORT
COMPUTE SUM OF trigger ON REPORT
COMPUTE SUM OF total ON REPORT
BREAK ON REPORT

SELECT O.owner,
Sum( Decode( o.object_type, 'TABLE', 1, 0)) tables,
Sum( Decode( o.object_type, 'INDEX', 1, 0)) AS "index",
Sum( Decode( o.object_type, 'VIEW', 1, 0)) AS "view",
Sum( Decode( o.object_type, 'MATERIALIZED VIEW', 1, 0)) AS "MV",
Sum( Decode( o.object_type, 'SEQUENCE', 1, 0)) AS "sequence",
Sum( Decode( o.object_type, 'SYNONYM', 1, 0)) AS "synonym",
Sum( Decode( o.object_type, 'CLUSTER', 1, 0)) AS "cluster",
Sum( Decode( o.object_type, 'PROCEDURE', 1,0)) AS "procedure",
Sum( Decode( o.object_type, 'PACKAGE', 1, 0)) AS "package",
Sum( Decode( o.object_type, 'PACKAGE BODY',1,0)) AS "package_body",
Sum( Decode( o.object_type, 'DATABASE LINK', 1,0)) AS "db_link",
Sum( Decode( o.object_type, 'TRIGGER',1,0)) AS "trigger",
count(*) "Total"
FROM   dba_objects o, (SELECT a.username
         FROM   dba_users a, dba_users b
         WHERE  a.created > (b.created + 1 / 24)
                AND b.username = 'SYS' &AgentFilter
         MINUS
         SELECT DISTINCT SCHEMA
         FROM   dba_registry) b
WHERE  o.owner = b.username
GROUP  BY o.owner
ORDER  BY 13 DESC, 1;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_constraint_count">Schema constraint count</h2>

prompt
prompt If the primary, unique or referential integrity constraints will be disabled during the migration, an assessment of the method and time required to enable the constraints should be considered.  Likely will be the choice of validate or novalidate [along with the application of a null check constraint on PK to avoid new data validation errors].
prompt

prompt
prompt U      - Undefined
prompt COT    - Check on Table
prompt COV    - Check on View
prompt ROOV   - ReadOnly on View
prompt PK     - Primary Key
prompt UK     - Unique Key
prompt RI     - Referential Integrity
prompt DRC    - Delete rule cascade
prompt DRSN   - Delete rule set null
prompt DRNA   - Delete rule no action
prompt

COLUMN owner  FORMAT a19 HEADING "Owner"
COLUMN u      FORMAT 999,999
COLUMN cot    FORMAT 999,999
COLUMN roov   FORMAT 999,999
COLUMN pk  FORMAT 999,999
COLUMN ri  FORMAT 999,999
COLUMN uk  FORMAT 999,999
COLUMN cov  FORMAT 999,999
COLUMN drc FORMAT 999,999
COLUMN drsn FORMAT 999,999
COLUMN drna FORMAT 999,999

compute sum of u on report
compute sum of cot on report
compute sum of cov on report
compute sum of roov on report
compute sum of pk on report
compute sum of uk on report
compute sum of ri on report
compute sum of drc on report
compute sum of drsn on report
compute sum of drna on report
compute sum of total on report
break on report

select o.owner,
Sum( Decode( o.constraint_type, '?', 1, 0)) AS u,
Sum( Decode( o.constraint_type, 'C', 1, 0)) AS cot,
Sum( Decode( o.constraint_type, 'V', 1, 0)) AS cov,
Sum( Decode( o.constraint_type, 'O', 1, 0)) AS roov,
Sum( Decode( o.constraint_type, 'P', 1, 0)) AS pk,
Sum( Decode( o.constraint_type, 'U', 1, 0)) AS uk,
Sum( Decode( o.constraint_type, 'R', 1, 0)) AS ri,
sum( decode( o.delete_rule,'CASCADE',1,0)) as drc,
sum( decode( o.delete_rule,'SET NULL',1,0)) as drsn,
sum( decode( o.delete_rule,'NO ACTION',1,0)) as drna,
count(*) as total
FROM   dba_constraints o, (SELECT a.username
         FROM   dba_users a, dba_users b
         WHERE  a.created > (b.created + 1 / 24)
                AND b.username = 'SYS' &AgentFilter
         MINUS
         SELECT DISTINCT SCHEMA
         FROM   dba_registry) b
WHERE  o.owner = b.username
GROUP  BY o.owner
ORDER  BY 9 DESC, 1;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_primary_keys_invalid">Schema primary keys invalid</h2>

prompt
prompt Invalid primary keys are ignored by GoldenGate supplemental logging
prompt

select o.owner,
Sum( Decode( o.constraint_type, '?', 1, 0)) AS u,
Sum( Decode( o.constraint_type, 'C', 1, 0)) AS cot,
Sum( Decode( o.constraint_type, 'V', 1, 0)) AS cov,
Sum( Decode( o.constraint_type, 'O', 1, 0)) AS roov,
Sum( Decode( o.constraint_type, 'P', 1, 0)) AS pk,
Sum( Decode( o.constraint_type, 'U', 1, 0)) AS uk,
Sum( Decode( o.constraint_type, 'R', 1, 0)) AS ri,
sum( decode( o.delete_rule,'CASCADE',1,0)) as drc,
sum( decode( o.delete_rule,'SET NULL',1,0)) as drsn,
sum( decode( o.delete_rule,'NO ACTION',1,0)) as drna,
count(*) as total
FROM   dba_constraints o, (SELECT a.username
         FROM   dba_users a, dba_users b
         WHERE  a.created > (b.created + 1 / 24)
                AND b.username = 'SYS' &AgentFilter
         MINUS
         SELECT DISTINCT SCHEMA
         FROM   dba_registry) b
WHERE  o.owner = b.username
and o.invalid = 'INVALID'
GROUP  BY o.owner
ORDER  BY 9 DESC, 1;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_primary_keys_missing_count">Schema primary keys missing count</h2>

prompt
prompt This is the count tables missing a primary or unique key by each schema
prompt

SELECT owner, COUNT(*)
FROM   (SELECT owner, table_name
         FROM   dba_tables, (SELECT a.username
                  FROM   dba_users a, dba_users b
                  WHERE  a.created > (b.created + 1 / 24)
                         AND b.username = 'SYS' &AgentFilter
                  MINUS
                  SELECT DISTINCT SCHEMA
                  FROM   dba_registry) b
         WHERE  owner = b.username
         MINUS
         SELECT owner, table_name
         FROM   dba_constraints, (SELECT a.username
                  FROM   dba_users a, dba_users b
                  WHERE  a.created > (b.created + 1 / 24)
                         AND b.username = 'SYS' &AgentFilter
                  MINUS
                  SELECT DISTINCT SCHEMA
                  FROM   dba_registry) b
         WHERE  owner = b.username
                AND constraint_type IN ('P', 'U')
         MINUS
         SELECT owner, table_name
         FROM   dba_external_tables)
GROUP  BY owner
ORDER  BY 1;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_PKUK_missing_list">Schema PKUK missing list</h2>

prompt Tables missing a Primary or Unique Key.  The row operation counts are obtained from all_tab_modifications from which statistics are cleared after each statistics gathering for a table.

SELECT a.owner,
       a.table_name,
       a.num_rows,
       b.inserts,
       b.updates,
       b.deletes,
       b.truncated
FROM   dba_tables a,
       all_tab_modifications b,
       (SELECT owner,
               table_name
        FROM   dba_tables
        WHERE  owner IN (SELECT a.username
                         FROM   dba_users a,
                                dba_users b
                         WHERE  a.created > (b.created + 1 / 24)
                                AND b.username = 'SYS' &AgentFilter
                         MINUS
                         SELECT DISTINCT SCHEMA
                         FROM   dba_registry)
        MINUS
        SELECT owner,
               table_name
        FROM   dba_constraints
        WHERE  constraint_type IN ('P', 'U')) c
WHERE  a.owner = c.owner
       AND a.owner = b.table_owner(+)
       AND a.table_name = c.table_name
       AND a.table_name = b.table_name(+)
ORDER  BY 1,
          2;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_keys_not_validated">Schema keys not validated</h2>

prompt
prompt Nonvalidated pk uk fk are ignored by GoldenGate supplemental logging
prompt


select o.owner,
Sum( Decode( o.constraint_type, '?', 1, 0)) AS u,
Sum( Decode( o.constraint_type, 'C', 1, 0)) AS cot,
Sum( Decode( o.constraint_type, 'V', 1, 0)) AS cov,
Sum( Decode( o.constraint_type, 'O', 1, 0)) AS roov,
Sum( Decode( o.constraint_type, 'P', 1, 0)) AS pk,
Sum( Decode( o.constraint_type, 'U', 1, 0)) AS uk,
Sum( Decode( o.constraint_type, 'R', 1, 0)) AS ri,
sum( decode( o.delete_rule,'CASCADE',1,0)) as drc,
sum( decode( o.delete_rule,'SET NULL',1,0)) as drsn,
sum( decode( o.delete_rule,'NO ACTION',1,0)) as drna,
count(*) as total
FROM   dba_constraints o, (SELECT a.username
         FROM   dba_users a, dba_users b
         WHERE  a.created > (b.created + 1 / 24)
                AND b.username = 'SYS' &AgentFilter
         MINUS
         SELECT DISTINCT SCHEMA
         FROM   dba_registry) b
WHERE  o.owner = b.username
and o.VALIDATED = 'NOT VALIDATED'
GROUP  BY o.owner
ORDER  BY 9 DESC, 1;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_public_objects">Schema public objects</h2>
prompt
prompt The owner object type contains a pointer (synonyms or functional call to an object in a replication schema).

prompt Public synonyms are the simple case, less obvious cases bespoke code embedded in the SYS schema.

prompt A working example includes Oracle E business suite in which many schema including APPLSYS and PO create triggers on tables owned by the APPS schema.

Prompt Datapump export only captures public synonyms in full export mode (full=y), but not schema level or table level mode.

prompt

SELECT TYPE "Source Object Type",
       owner || '.' || NAME "Source Object",
       referenced_type "Target Object Type",
       referenced_owner || '.' || referenced_name "Target Object"
FROM   dba_dependencies
WHERE  referenced_owner IN (SELECT a.username
                            FROM   dba_users a,
                                   dba_users b
                            WHERE  a.created > (b.created + 1 / 24)
                                   AND b.username = 'SYS' &AgentFilter
                            MINUS
                            SELECT DISTINCT SCHEMA
                            FROM   dba_registry)
       AND owner NOT IN (SELECT a.username
                         FROM   dba_users a,
                                dba_users b
                         WHERE  a.created > (b.created + 1 / 24)
                                AND b.username = 'SYS' &AgentFilter
                         MINUS
                         SELECT DISTINCT SCHEMA
                         FROM   dba_registry)
ORDER  BY 1,
          2,
          3,
          4;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_segment_analysis">Schema segment analysis</h2>
prompt
prompt For every schema occupying more than 0.1mb of segments, this table illustrates the total MegaBytes for each of the segment types.  The XDB schema is included in this report in an attempt to catch situations where the XDB schema is used as a document store.
prompt


DECLARE

  TYPE t_seg_rec IS RECORD(
    cluster_mb            NUMBER,
    index_mb              NUMBER,
    index_partition_mb    NUMBER,
    index_subpartition_mb NUMBER,
    lob_partition_mb      NUMBER,
    lob_subpartition_mb   NUMBER,
    lobindex_mb           NUMBER,
    lobsegment_mb         NUMBER,
    nested_table_mb       NUMBER,
    table_mb              NUMBER,
    table_partition_mb    NUMBER,
    table_subpartition_mb NUMBER);

  TYPE t_seg_tab IS TABLE OF t_seg_rec INDEX BY dba_segments.owner%TYPE;
  seg_tab t_seg_tab;

  CURSOR mycur IS
    SELECT owner,
           segment_type,
           round(SUM(bytes) / 1024 / 1024, 1) mb
    FROM   dba_segments
    WHERE  owner IN (SELECT a.username
                     FROM   dba_users a,
                            dba_users b
                     WHERE  a.created > (b.created + 1 / 24)
                            AND b.username = 'SYS' &AgentFilter
                     MINUS (SELECT DISTINCT SCHEMA FROM dba_registry)
                     UNION
                     SELECT DISTINCT SCHEMA
                     FROM   dba_registry
                     WHERE  SCHEMA IN ('XDB'))
    GROUP  BY owner,
              segment_type;

  PROCEDURE print IS
    s      dba_segments.owner%TYPE;
    rp     NUMBER := 12;
    itotal NUMBER;

  BEGIN
    dbms_output.enable(1000000);

    dbms_output.put(rpad('owner', 25) || ',');
    dbms_output.put(lpad('total', rp) || ',');
    dbms_output.put(lpad('tab', rp) || ',');
    dbms_output.put(lpad('tab_part', rp) || ',');
    dbms_output.put(lpad('tab_subpart', rp) || ',');
    dbms_output.put(lpad('ind', rp) || ',');
    dbms_output.put(lpad('ind_part', rp) || ',');
    dbms_output.put(lpad('ind_subpart', rp) || ',');
    dbms_output.put(lpad('lobseg', rp) || ',');
    dbms_output.put(lpad('lobind', rp) || ',');
    dbms_output.put(lpad('lob_part', rp) || ',');
    dbms_output.put(lpad('lob_subpart', rp) || ',');
    dbms_output.put(lpad('cluster', rp) || ',');
    dbms_output.put_line(lpad('nested_table', rp));

    dbms_output.put(rpad('-', 25, '-') || ',');
    dbms_output.put(lpad('-', rp, '-') || ',');
    dbms_output.put(lpad('-', rp, '-') || ',');
    dbms_output.put(lpad('-', rp, '-') || ',');
    dbms_output.put(lpad('-', rp, '-') || ',');
    dbms_output.put(lpad('-', rp, '-') || ',');
    dbms_output.put(lpad('-', rp, '-') || ',');
    dbms_output.put(lpad('-', rp, '-') || ',');
    dbms_output.put(lpad('-', rp, '-') || ',');
    dbms_output.put(lpad('-', rp, '-') || ',');
    dbms_output.put(lpad('-', rp, '-') || ',');
    dbms_output.put(lpad('-', rp, '-') || ',');
    dbms_output.put(lpad('-', rp, '-') || ',');
    dbms_output.put_line(lpad('-', rp, '-'));

    s := seg_tab.first;
    LOOP
      EXIT WHEN s IS NULL;

      seg_tab(s).cluster_mb := nvl(seg_tab(s).cluster_mb, 0);
      seg_tab(s).index_mb := nvl(seg_tab(s).index_mb, 0);
      seg_tab(s).index_partition_mb := nvl(seg_tab(s).index_partition_mb, 0);
      seg_tab(s).index_subpartition_mb := nvl(seg_tab(s).index_subpartition_mb, 0);
      seg_tab(s).lob_partition_mb := nvl(seg_tab(s).lob_partition_mb, 0);
      seg_tab(s).lob_subpartition_mb := nvl(seg_tab(s).lob_subpartition_mb, 0);
      seg_tab(s).lobindex_mb := nvl(seg_tab(s).lobindex_mb, 0);
      seg_tab(s).lobsegment_mb := nvl(seg_tab(s).lobsegment_mb, 0);
      seg_tab(s).nested_table_mb := nvl(seg_tab(s).nested_table_mb, 0);
      seg_tab(s).table_mb := nvl(seg_tab(s).table_mb, 0);
      seg_tab(s).table_partition_mb := nvl(seg_tab(s).table_partition_mb, 0);
      seg_tab(s).table_subpartition_mb := nvl(seg_tab(s).table_subpartition_mb, 0);

      itotal := seg_tab(s).cluster_mb + seg_tab(s).index_mb + seg_tab(s).index_partition_mb + seg_tab(s)
                .index_subpartition_mb + seg_tab(s).lob_partition_mb + seg_tab(s).lob_subpartition_mb + seg_tab(s)
                .lobindex_mb + seg_tab(s).lobsegment_mb + seg_tab(s).nested_table_mb + seg_tab(s).table_mb + seg_tab(s)
                .table_partition_mb + seg_tab(s).table_subpartition_mb;

      dbms_output.put(rpad(s, 25) || ',');
      dbms_output.put(lpad(itotal, rp) || ',');
      dbms_output.put(lpad(seg_tab(s).table_mb, rp) || ',');
      dbms_output.put(lpad(seg_tab(s).table_partition_mb, rp) || ',');
      dbms_output.put(lpad(seg_tab(s).table_subpartition_mb, rp) || ',');
      dbms_output.put(lpad(seg_tab(s).index_mb, rp) || ',');
      dbms_output.put(lpad(seg_tab(s).index_partition_mb, rp) || ',');
      dbms_output.put(lpad(seg_tab(s).index_subpartition_mb, rp) || ',');
      dbms_output.put(lpad(seg_tab(s).lobsegment_mb, rp) || ',');
      dbms_output.put(lpad(seg_tab(s).lobindex_mb, rp) || ',');
      dbms_output.put(lpad(seg_tab(s).lob_partition_mb, rp) || ',');
      dbms_output.put(lpad(seg_tab(s).lob_subpartition_mb, rp) || ',');
      dbms_output.put(lpad(seg_tab(s).cluster_mb, rp) || ',');
      dbms_output.put_line(lpad(seg_tab(s).nested_table_mb, rp));

      s := seg_tab.next(s);
    END LOOP;

  END;

BEGIN

  FOR myrows IN mycur LOOP

    IF (myrows.segment_type = 'INDEX') THEN
      seg_tab(myrows.owner).index_mb := myrows.mb;
    ELSE
      IF (myrows.segment_type = 'TABLE') THEN
        seg_tab(myrows.owner).table_mb := myrows.mb;
      ELSE
        IF (myrows.segment_type = 'TABLE PARTITION') THEN
          seg_tab(myrows.owner).table_partition_mb := myrows.mb;
        ELSE
          IF (myrows.segment_type = 'TABLE SUBPARTITION') THEN
            seg_tab(myrows.owner).table_subpartition_mb := myrows.mb;
          ELSE
            IF (myrows.segment_type = 'INDEX PARTITION') THEN
              seg_tab(myrows.owner).index_partition_mb := myrows.mb;
            ELSE
              IF (myrows.segment_type = 'INDEX SUBPARTITION') THEN
                seg_tab(myrows.owner).index_subpartition_mb := myrows.mb;
              ELSE
                IF (myrows.segment_type = 'LOBSEGMENT') THEN
                  seg_tab(myrows.owner).lobsegment_mb := myrows.mb;
                ELSE
                  IF (myrows.segment_type = 'LOBINDEX') THEN
                    seg_tab(myrows.owner).lobindex_mb := myrows.mb;
                  ELSE
                    IF (myrows.segment_type = 'LOB PARTITION') THEN
                      seg_tab(myrows.owner).lob_partition_mb := myrows.mb;
                    ELSE
                      IF (myrows.segment_type = 'LOB SUBPARTITION') THEN
                        seg_tab(myrows.owner).lob_subpartition_mb := myrows.mb;
                      ELSE
                        IF (myrows.segment_type = 'CLUSTER') THEN
                          seg_tab(myrows.owner).cluster_mb := myrows.mb;
                        ELSE
                          IF (myrows.segment_type = 'NESTED TABLE') THEN
                            seg_tab(myrows.owner).nested_table_mb := myrows.mb;
                          END IF;
                        END IF;
                      END IF;
                    END IF;
                  END IF;
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;

  END LOOP;

  print;

END;
/

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_sequences">Schema sequences</h2>
prompt
prompt Sequence treatment needs to be considered for each database platform. Low transaction systems can use the OGG replication facilities.  Very high transaction system may have to delay sequence migration for some or all of the sequences until the migration night.  Always attempt to replicate sequences with GoldenGate until it becomes clear that the replication lag is adversely affected by sequence replication.

prompt In active-active environment, sequence replication is not supported, and therefore the application design must ensure sequence values fall into distinct subsets.

SELECT sequence_owner, COUNT(*)
FROM   dba_sequences
WHERE  sequence_owner IN (SELECT a.username
                          FROM   dba_users a, dba_users b
                          WHERE  a.created > (b.created + 1 / 24)
                                 AND b.username = 'SYS' &AgentFilter
                          MINUS
                          SELECT DISTINCT SCHEMA
                          FROM   dba_registry)
GROUP  BY sequence_owner
ORDER  BY 1;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_domain_indexes">Schema domain indexes</h2>

prompt
prompt   A domain index is an index designed for a specialized domain, such as spatial or image processing.  As a domain index is stored within a table structure rather than an indexes structure, the tablespace column of dba and user indexes tables is null.
prompt  The follow is the list of user domain indexes

SELECT owner,
       index_name,
       index_type,
       table_owner,
       table_name
FROM   dba_indexes a,
       (SELECT a.username
        FROM   dba_users a,
               dba_users b
        WHERE  a.created > (b.created + 1 / 24)
               AND b.username = 'SYS' &AgentFilter
        MINUS
        SELECT DISTINCT SCHEMA
        FROM   dba_registry) b
WHERE  a.tablespace_name IS NULL
       AND a.owner = b.username
ORDER  BY 1,
          2;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_deferred_constraints">Schema deferred constraints</h2>

prompt
prompt  Deferred constaints may cause ADD TRANDATA to select the wrong column for logging. Use KEYCOLS for tables with deferred constaints
prompt

SELECT DISTINCT owner,
                constraint_name,
                constraint_type,
                table_name,
                deferrable,
                deferred
FROM   dba_constraints a,
       (SELECT a.username
        FROM   dba_users a,
               dba_users b
        WHERE  a.created > (b.created + 1 / 24)
               AND b.username = 'SYS' &AgentFilter
        MINUS
        SELECT DISTINCT SCHEMA
        FROM   dba_registry) b
WHERE  a.owner = b.username
       AND (deferrable = 'DEFERRABLE' OR deferred = 'DEFERRED');

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_data_type_usage_summary">Schema data type usage summary</h2>
prompt
prompt This is a numeric count of each table column data type used by each schema.  Take notice of any ROWID counts as tables with ROWID columns may cause replication problems.  ROWID columns data can be replicated but in a logically instantiated target database, that is a database built using export/import, datapump, data unloading, the ROWID values may no longer correctly point to a valid row.  If the target database is a physical replica, the ROWID values may be valid, but only for the instantiation. As replication is purely SQL driven by inserts, update and deletes, a rowid may not replicate in a meaningful context.  Therefore you should analyse usage of the tables containing a ROWID data type.

prompt

break on data_type

SELECT a.data_type, a.owner, COUNT(*)
FROM   dba_tab_cols a, (SELECT a.username
         FROM   dba_users a, dba_users b
         WHERE  a.created > (b.created + 1 / 24)
                AND b.username = 'SYS' &AgentFilter
         MINUS
         SELECT DISTINCT SCHEMA
         FROM   dba_registry) b
WHERE  a.owner = b.username
GROUP  BY data_type, owner
ORDER  BY 1, 2;


prompt


prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_non_scalar_columns">Schema non scalar columns</h2>
prompt
prompt BLOB, CLOB, LONG, LONG RAW, NCLOB, XMLTYPE form an interesting consideration because they generally contain reasonably large amounts of data that will place a sufficiently heavy load on the GoldenGate capture throughput that may cause lag to appear throughout the system.  Of course, shifting large volumes of data does not imply a performace problem, simply a delay, or lag, caused by the burden of a heavy load.

prompt Additionally the BLOB, CLOB, LONG, LONG RAW, NCLOB, XMLTYPE columns may cause extract to fetch the some or all rows from the database, due to row chaining which is likely with large objects that span many database blocks.  In these cases the extract processes uses flashback queries to get a read consistent value of the row to capture the change data.

prompt As a flashback queries are going to be more computationally more intensive than a online redo log file scan or archive log scan, fetching these data-types could place additional load on the GoldenGate infrastructure, again represented as further lag.

break on data_type

SELECT data_type, owner, table_name, column_name
FROM   all_tab_columns a, (SELECT a.username
         FROM   dba_users a, dba_users b
         WHERE  a.created > (b.created + 1 / 24)
                AND b.username = 'SYS' &AgentFilter
         MINUS
         SELECT DISTINCT SCHEMA
         FROM   dba_registry) b
WHERE  a.owner = b.username
       AND data_type IN ('CLOB', 'BLOB', 'LONG', 'LONG RAW', 'NCLOB','XMLTYPE')
ORDER  BY 1, 2, 3, 4;

prompt


prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_one_column_tables">Schema one column tables</h2>
prompt
prompt Single column tables with non scalar data types generally cannot be replicated because in update/delete situations the target row cannot be identified using a "select where" SQL construct.  Generally the treatment for the non scalar tables is to exclude them from replication and transfer them during the migration outage window.

prompt

SELECT a.data_type, a.owner, a.table_name
FROM   dba_tab_cols a, (SELECT owner, table_name
         FROM   dba_tab_cols, (SELECT a.username
                  FROM   dba_users a, dba_users b
                  WHERE  a.created > (b.created + 1 / 24)
                         AND b.username = 'SYS' &AgentFilter
                  MINUS
                  SELECT DISTINCT SCHEMA
                  FROM   dba_registry) b
         WHERE  owner = b.username
                AND table_name NOT LIKE 'BIN$%'
         GROUP  BY owner, table_name
         HAVING MAX(column_id) = 1) b
WHERE  data_type NOT IN ('NUMBER', 'FLOAT', 'CHAR', 'DATE', 'NCHAR', 'VARCHAR2', 'NVARCHAR2')
       AND b.table_name = a.table_name
       AND b.owner = a.owner
order by 1,2,3;


prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_unused_column_tables">Schema unused column tables</h2>

prompt
prompt Tables with unused columns are not directly replicable with GoldenGate so the approach can be a little complicated in so much that you need to defgen the source table and create a SOURCEDEFS entry in the target replicat.  However, when we used SOURCEDEFS replicat cannot apply DDL to the affected target because with SOURCEDEFS we have created a static dictionary metadata entry.  Not only DDL that modified the table column structure but also DDL for table partitioning.  And it is the partitioning element that is generally the reason we need to know about unused columns.

SELECT a.owner,
       a.table_name,
       b.partitioned partitioned_table,
       d.column_name
FROM   dba_unused_col_tabs a,
       dba_tables b,
       (SELECT a.username
        FROM   dba_users a,
               dba_users b
        WHERE  a.created > (b.created + 1 / 24)
               AND b.username = 'SYS' &AgentFilter
        MINUS
        SELECT DISTINCT SCHEMA
        FROM   dba_registry) c,
       dba_tab_cols d
WHERE  a.owner = c.username
       AND a.owner = b.owner
       AND a.table_name = b.table_name
       AND a.owner = d.owner
       AND a.table_name = d.table_name
       AND d.hidden_column = 'YES';

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_hidden/invisible_column_tables">Schema hidden/invisible column tables</h2>
prompt
prompt In Oracle Database 12c, table columns can be defined as invisible either during its creation with the CREATE TABLE command or by modifying existing table columns via the ALTER TABLE statement. By default, table columns are always visible. Once a column has been set to invisible, it can be reverted back to visible using the ALTER TABLE statement.

SELECT data_type, owner, table_name, column_name
FROM   dba_tab_cols a,
       (SELECT a.username
        FROM   dba_users a,
               dba_users b
        WHERE  a.created > (b.created + 1 / 24)
               AND b.username = 'SYS' &AgentFilter
        MINUS
        SELECT DISTINCT SCHEMA
        FROM   dba_registry) b
WHERE  owner = b.username
       AND a.hidden_column = 'YES'
       order by 1,2,3,4;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_unsupported_column_types">Schema unsupported column types</h2>
prompt
prompt Tables containing any of the following data types need special treatment in the GoldenGate classic extract mode.  Mostly these tables are candidates to be excluded from replication but there may use cases where the supported columns are replicated and the unsupported column values pragmatically treated at the target database.  The decision to replicate the table or exclude and transport during the database migration window will depend largely on the size of the table, the time to transfer the table and the cost/value of the unsupported column - in cases where the unsupported column has a very low cost/value, it may be expedient to exclude the affected column.

SELECT a.data_type, b.object_type, a.owner, a.table_name
FROM   dba_tab_cols a, dba_objects b, (SELECT a.username
         FROM   dba_users a, dba_users b
         WHERE  a.created > (b.created + 1 / 24)
                AND b.username = 'SYS' &AgentFilter
         MINUS
         SELECT DISTINCT SCHEMA
         FROM   dba_registry) c
WHERE  a.owner = b.owner
       AND a.owner = c.username
       AND b.owner = c.username
       AND a.table_name = b.object_name
       AND (a.data_type IN ('ANYDATA', 'ANYDATASET', 'ANYTYPE', 'BFILE', 'BINARY_INTEGER', 'MLSLABEL', 'ORDDICOM', 'PLS_INTEGER', 'UROWID', 'TIMEZONE_ABBR', 'TIMEZONE_REGION', 'URITYPE') OR
       a.data_type LIKE 'INTERVAL%')
ORDER  BY 1, 2, 3, 4;

prompt

prompt The ROWID data-type is replicated by GoldenGate, but you must consider whether the ROWID will be valid in the target database.  Generally, the ROWID value will not point to the correct table row when it gets to the target database, but that understanding really only derives from your own understanding of your business data.

prompt ROWID are not always stored as a ROWID data-type, occasionally we find the ROWID are stored as VARCHAR2 but finding the tables can be a little tricky.  The following listing attempts to find the tricky subset of ROWID in varchar2 and includes the ROWID data-types as well.

prompt UROWID is supported from GoldenGate 12.1.2.0.x, Integrated Capture, but not classic capture.


SELECT a.data_type, b.object_type, a.owner, a.table_name, a.column_name
FROM   dba_tab_cols a, dba_objects b, (SELECT a.username
         FROM   dba_users a, dba_users b
         WHERE  a.created > (b.created + 1 / 24)
                AND b.username = 'SYS' &AgentFilter
         MINUS
         SELECT DISTINCT SCHEMA
         FROM   dba_registry) c
WHERE  a.owner = b.owner
       AND a.owner = c.username
       AND b.owner = c.username
       AND a.table_name = b.object_name
       and (table_name LIKE '%ROWID%' OR table_name LIKE '%ROW_ID%' OR column_name LIKE '%ROWID%' OR column_name LIKE '%ROW_ID%' OR data_type = 'ROWID')
       and object_type != 'VIEW'
ORDER  BY 1, 2, 3, 4;

-- SELECT data_type, owner, table_name, column_name
-- FROM   dba_tab_cols, (SELECT a.username
--          FROM   dba_users a, dba_users b
--          WHERE  a.created > (b.created + 1 / 24)
--                 AND b.username = 'SYS' &AgentFilter
--          MINUS
--          SELECT DISTINCT SCHEMA
--          FROM   dba_registry) b
-- WHERE  (table_name LIKE '%ROWID%' OR table_name LIKE '%ROW_ID%' OR column_name LIKE '%ROWID%' OR column_name LIKE '%ROW_ID%' OR data_type = 'ROWID')
--        and table_name != 'CHAINED_ROWS'
--        AND owner = b.username
-- ORDER  BY 1, 2, 3, 4;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_compressed_tables">Schema compressed tables</h2>


prompt Any table with compression enabled cannot be captured with classic GoldenGate replication.  The typical approach for these tables is to exclude them from replication but to migrate them using CTAS or export/import or datapump.

prompt

SELECT t.owner,
       t.table_name,
       t.num_rows,
       t.last_analyzed,
       round(s.bytes / 1024 / 1024 / 1024,2) gb
FROM   dba_tables t,
       (SELECT owner,
               segment_name,
               SUM(bytes) bytes
        FROM   dba_segments
        WHERE  owner IN (SELECT a.username
                         FROM   dba_users a,
                                dba_users b
                         WHERE  a.created > (b.created + 1 / 24)
                                AND b.username = 'SYS' &AgentFilter
                         MINUS
                         SELECT DISTINCT SCHEMA
                         FROM   dba_registry)
        GROUP  BY owner,
                  segment_name) s,
       (SELECT a.username
        FROM   dba_users a,
               dba_users b
        WHERE  a.created > (b.created + 1 / 24)
               AND b.username = 'SYS' &AgentFilter
        MINUS
        SELECT DISTINCT SCHEMA
        FROM   dba_registry) b
WHERE  t.compression = 'ENABLED'
       AND b.username = t.owner
       AND t.owner = s.owner
       AND t.table_name = s.segment_name;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Schema_50_biggest_tables">Schema 50 biggest tables</h2>

prompt
prompt Large tables are necessarily difficult to migrate, but when they are missing a PKUK then logical replication may not be possible.  Large table with lots of indexes are a problem for export/import migrations.
prompt

select
  a.owner || '.' || a.table_name "Table Name",
  round(c.m_bytes,2) m_bytes,
  a.blocks table_blocks,
  a.compression,
  a.dropped,
  a.partitioned,
  nvl(d.encrypted_columns,0) encrypted_columns,
  nvl(e.pkuk_constraints,0) pkuk_constraints,
  nvl(f.total_indexes,0) total_indexes
from
  (SELECT owner, table_name, blocks, compression, dropped, partitioned FROM dba_tables WHERE owner NOT IN ('SYS','SYSTEM')) a,
  (SELECT a.username FROM dba_users a, dba_users b WHERE a.created > (b.created + 1 / 24) AND b.username = 'SYS' &AgentFilter MINUS SELECT DISTINCT SCHEMA FROM dba_registry) b,
  (SELECT owner, segment_name, m_bytes FROM (select owner, segment_name, sum(bytes)/1024/1024 m_bytes from dba_segments where owner NOT IN ('SYS','SYSTEM') AND segment_type NOT IN ('ROLLBACK', 'TYPE2 UNDO') AND segment_type NOT LIKE '%INDEX%' GROUP BY owner, segment_name order by sum(bytes)/1024/1024 DESC) WHERE ROWNUM < 51) c,
  (select owner, table_name, count(*) encrypted_columns from dba_encrypted_columns group by owner, table_name) d,
  (select owner, table_name, count(*) pkuk_constraints from dba_constraints WHERE owner NOT IN ('SYS','SYSTEM') and constraint_type in ('P','U') group by owner, table_name) e,
  (select owner, table_name, count(*) total_indexes from dba_indexes where owner NOT IN ('SYS','SYSTEM') group by owner, table_name) f
WHERE
  a.owner = b.username and
  a.owner = c.owner(+) and a.table_name = c.segment_name and
  a.owner = d.owner(+) and a.table_name = d.table_name(+) and
  a.owner = e.owner(+) and a.table_name = e.table_name(+) and
  a.owner = f.owner(+) and a.table_name = f.table_name(+)
 order by m_bytes DESC
;

/*
SELECT round(bytes / 1024 / 1024 / 1024, 2) gbyte, segment_type "Type", owner, segment_name "Object", partition_name
FROM   (SELECT owner, segment_name, segment_type, partition_name, bytes
         FROM   dba_segments, (SELECT a.username
                  FROM   dba_users a, dba_users b
                  WHERE  a.created > (b.created + 1 / 24)
                         AND b.username = 'SYS' &AgentFilter
                  MINUS
                  SELECT DISTINCT SCHEMA
                  FROM   dba_registry) b
         WHERE  owner = b.username
                AND segment_type NOT IN ('ROLLBACK', 'TYPE2 UNDO')
                AND segment_type NOT LIKE '%INDEX%'
         ORDER  BY bytes DESC)
WHERE  rownum < 51
ORDER  BY 1 DESC, 2, 3, 4;
*/

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Tool_-_Datapump">Tool - Datapump</h2>

prompt
prompt The datapump tool has a couple of restrictions that should be considered
prompt 1. impdp over a network link can reach 2 full versions down.  So 12.1.0.2 database can import over a network link from 10.2.0.5
prompt 2. impdp over a network link can reach 1 full version up.  So 10.2.0.5 can import over a network link from 11.2.0.4
prompt 3. impdp over a network link cannot import tables containing a LONG column data-type
prompt These tables cannot be imported over a network_link because of the LONG data-type

SELECT owner, table_name, data_type, COUNT(*)
FROM   dba_tab_cols
WHERE  owner IN (SELECT a.username
                 FROM   dba_users a, dba_users b
                 WHERE  a.created > (b.created + 1 / 24)
                        AND b.username = 'SYS' &AgentFilter
                 MINUS
                 SELECT DISTINCT SCHEMA
                 FROM   dba_registry)
       AND data_type = 'LONG'
GROUP  BY owner, table_name, data_type
ORDER  BY owner, table_name;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Tool_-_GoldenGate">Tool - GoldenGate</h2>
prompt
prompt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prompt .s2:  Major feature availability
prompt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prompt

prompt Classic capture dblogreader from database 10.2.0.5 but not 11.1.x
prompt Classic Coordinated apply from GoldenGate 12.1.2.0.0
prompt Integrated data capture from database 11.2.0.3.0 with bundle patch for Integrated Extract 11.2.x (Doc ID 1557031.1)
prompt Integrated DDL capture from database 11.2.0.4
prompt Integrated apply from database 11.2.0.4 with GoldenGate 12.1.2.0.0
prompt add schematrandata from database 10.2.0.5 with GoldenGate 11.2
prompt add schematrandata from database 11.2.0.3 with GoldenGate 11.2
prompt

prompt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prompt .s2:  Schema - Mixed case schema owners or objects
prompt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
prompt

prompt Oracle database naming conventions are case insensitive which is actually another way of hinting to the fact that all
prompt object names are stored in uppercase in the dictionary tables.  However, it is possible for users to create case
prompt sensitive objects in application schema.  So it is worth quickly checking for any case sensitive object that may affect our
prompt migration.
prompt

prompt Mixed case tables are supported from OGG 11.2, but if you are forced to use a lower OGG version
prompt <pre>
prompt ALTER TABLE "MixedTableName" add SUPPLEMENTAL LOG DATA (ALL) COLUMNS;
prompt create NEWTABLE as select * from "MixedTableName" where 1=0;
prompt </pre>
prompt Add to extract parameter file:
prompt <pre>
prompt Table schema.NEWTABLE, ALTID < OBJECT_ID of the original mixed case table> ;
prompt   select object_id from all_objects where owner='SCHEMA' and table_name = 'MixedTableName';
prompt </pre>
prompt

prompt The list of users stored in mixed case
prompt

SELECT a.username
FROM   dba_users a, (SELECT a.username
         FROM   dba_users a, dba_users b
         WHERE  a.created > (b.created + 1 / 24)
                AND b.username = 'SYS' &AgentFilter
         MINUS
         SELECT DISTINCT SCHEMA
         FROM   dba_registry) b
WHERE  a.username = b.username
       AND a.username != upper(a.username)
ORDER  BY 1;


prompt
prompt The list of tables stored in mixed case
prompt

SELECT owner, table_name
FROM   dba_tables a, (SELECT a.username
         FROM   dba_users a, dba_users b
         WHERE  a.created > (b.created + 1 / 24)
                AND b.username = 'SYS' &AgentFilter
         MINUS
         SELECT DISTINCT SCHEMA
         FROM   dba_registry) b
WHERE  a.owner = b.username
       AND a.table_name != upper(a.table_name)
ORDER  BY 1, 2;

prompt

prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="Tool_-_Oracle_Migration_Manager">Tool - Oracle Migration Manager</h2>

prompt
prompt <ul><li>NFS storage for classic and datapump export can be written to networked storage</li><li>Only use decicated local file system for OMM scheduler on target</li><li>Install on source /u01/omm</li><li>Install on target /u01/omm</li><li>SSH equivalence from source to target</li><li>Firewalls open from target to source for SQLNET, SSH</li><li>Firewalls open from source to target to for GoldenGate is using only migration</li><li>Network needs sufficient real world throughput to support replication</li></ul>
prompt
prompt The following is a list of parent schema that create triggers on child schema tables, though this is only interest from an OMM perspective when the trigger owner is an application schema because it is possible that the trigger owner schema will need to be managed so that the schema import occurs late in the transition phase.  After reviewing the following listings, it may become obvious that certain schema need to be migrated at the end of the transition phase.  You can achieve delayed transition by manually adding "exit 1" to the start of the parent schema import shell script and by setting the scheduler NUM_JOBS_IMP=1, NUM_JOBS_IDP=1 which ensure the non parent imports occur in sequence order.  After the infrastructure imports have completed, ramp up the NUM_JOBS_* parameters to figures that strain the target environment.  When the child schema imports have completed successfully, remove "exit 1" from the parent schema import and re-submit the parent schema import.
prompt

SELECT owner trigger_owner,
       table_owner,
       COUNT(*)
FROM   dba_triggers
WHERE  owner != table_owner
       AND base_object_type != 'DATABASE'
GROUP  BY owner,
          table_owner
ORDER  BY 1,
          2;

prompt
prompt The following is a list of parent schema that create index on child schema tables.  Similar to the triggers issue, it may be advisable to delay the parent schema import.
prompt

SELECT owner,
       table_owner,
       COUNT(*)
FROM   dba_indexes
WHERE  owner != table_owner
GROUP  BY owner,
          table_owner
ORDER  BY 1,
          2;

prompt
prompt Sometimes we find that procedural code stored in a referenced schema has not been installed to the target database, for example EBS migration requires that AD_CTX_DDL be loaded into the CTXSYS schema during the database build.  So, the follow table attempts to help focus our attention to any referenced schema objects that may need special treated at the target database (such as installing).
prompt

SELECT DISTINCT owner,
                referenced_owner,
                referenced_name,
                referenced_type
FROM   dba_dependencies
WHERE  referenced_type IN ('FUNCTION',
                           'PACKAGE BODY',
                           'PACKAGE',
                           'PROCEDURE',
                           'TRIGGER')
       AND owner NOT IN ('SYS',
                         'PUBLIC')
       AND referenced_owner NOT IN ('SYS')
       AND owner != referenced_owner
ORDER  BY 1,
          2,
          3,
          4;

prompt

prompt
prompt O2O/OOO does not support 4kb+ triggers.  The follow list of triggers will have to be migrated during post migration (PMCL).
prompt

select owner,
       name,
       type,
       sum(length(text))
  from dba_source
 where type = 'TRIGGER'
   and owner in (SELECT a.username
                   FROM dba_users a,
                        dba_users b
                  WHERE a.created > (b.created + 1 / 24)
                    AND b.username = 'SYS'
                 MINUS
                 SELECT DISTINCT SCHEMA
                   FROM dba_registry)
 HAVING sum(length(text)) > 3500
 GROUP BY OWNer,
          name,
          TYPE
 ORDER BY 1,
          2,
          3;

prompt
prompt <a href="#z-header">Back to Top</a>
prompt <h2 id="And_finally.">And finally.</h2>

set timing off

prompt
prompt This is the end of the document.  The generation runtime for this report is usually determined by the number of database objects and to some extent the volume of data.  However, sometimes, after adding some new code, the runtime increases.  Having a collection of runtimes from a large range of databases helps me keep track areas of unreasonable performance, which is why the final table exists below.
prompt

select
  '&time_start' "Report Start Time",
  to_char(sysdate,'dd-mon-yyyy hh24:mi:ss') "Report End Time",
  round(1440 * (sysdate - to_date('&time_start','dd-mon-yyyy hh24:mi:ss')),2) "Report Elapsed Minutes",
  (select round(sum(bytes)/1024/1024/1024,2) from dba_data_files) "Database Size GB",
  (select count(*) from dba_objects) "Database Object Count",
  '&1, &2, &3' "Schema Filter"
from dual;

prompt
prompt <a href="#z-header">Back to Top</a>

set markup HTML OFF
set define OFF

--The prompt removes trailing semicolon characters
prompt <script>

prompt var cssRules = [
prompt { selector: '.TT b          ', rules: 'font-family:Trebuchet MS,Arial,Helvetica,sans-serif;color:red;' },
prompt { selector: '.TT caption    ', rules: 'font-size:1em;color:#004000; caption-side: top;' },
prompt { selector: '.TT table      ', rules: 'table-layout:auto;' },
prompt { selector: '.TT td         ', rules: 'font-size:.7em;border:1px solid #98bf21;padding:3px 7px 2px;background-color:#F1F1F1;' },
prompt { selector: '.TT th         ', rules: 'font-size:1em;text-align:left;padding-top:5px;padding-bottom:4px;background-color:#A7C942;color:#000;' },
prompt { selector: '.TT            ', rules: 'caption-side: bottom; flex-wrap: nowrap; font-family:Trebuchet MS,Arial,Helvetica,sans-serif;' },
prompt { selector: '.button        ', rules: 'background-color: #336699; border: none; color: white; padding: 1px 5px; text-align: center; text-decoration: none; display: inline-block; font-size: 16px; margin: 4px 2px; cursor: pointer; border-radius: 2px;' },
prompt { selector: '.cell-left     ', rules: 'display: table-cell; width: 50%;font-size:.7em;border:1px solid #98bf21;padding:3px 7px 2px;background-color:#F1F1F1;' },
prompt { selector: '.cell-right    ', rules: 'display: table-cell; nowrap; width: 50%;font-size:.7em;border:1px solid #98bf21;padding:3px 7px 2px;background-color:#F1F1F1;' },
prompt { selector: '.close         ', rules: 'color: white; float: right; font-size: 28px; font-weight: bold;'},
prompt { selector: '.close:hover   ', rules: 'color: #000; text-decoration: none; cursor: pointer;'},
prompt { selector: '.close:focus   ', rules: 'color: #000; text-decoration: none; cursor: pointer;'},
prompt { selector: '.column-center ', rules: 'width=33%; padding: 4px;' },
prompt { selector: '.column-left   ', rules: 'float: left; width=33%;  padding: 4px;' },
prompt { selector: '.column-right  ', rules: 'float: right; width=33%; padding: 4px;' },
prompt { selector: '.modal         ', rules: 'display: none; position: fixed; z-index: 1; padding-top: 100px; left: 0; top: 0; width:0 ; height: 100%; width: 100%; overflow: auto;   background-color: rgba(0,0,0,0.4);' },
prompt { selector: '.modal-body    ', rules: 'padding: 2px 16px;' },
prompt { selector: '.modal-content ', rules: 'position: relative; background-color: #fefefe; margin: auto; padding: 0; border: 1px solid #888; width: 90%;' },
prompt { selector: '.modal-header  ', rules: 'padding: 20px; background-color: #5cb85c; color: white;' },
prompt { selector: '.modal-footer  ', rules: 'padding: 2px 16px; background-color: #5cb85c; color: white;' },
prompt { selector: '.row           ', rules: 'display: table-row;' },
prompt { selector: '.column        ', rules: 'float: left;  padding: 30px;' },
prompt { selector: '.row:after     ', rules: 'content: ""; display: table; clear: both;' },
prompt { selector: 'a              ', rules: 'font:Arial,Helvetica,sans-serif;color:#630;vertical-align:top;margin-top:0;margin-bottom:0;' },
prompt { selector: 'body           ', rules: 'border-left:.5em solid #EBEBEB;border-right:.5em solid #EBEBEB;border-top:.5em solid #d3d3d3;border-bottom:.5em solid #d3d3d3;font:1em Arial,Helvetica,Geneva,sans-serif;color:#000;background:#F8F8F8;' },
prompt { selector: 'h1             ', rules: 'font:bold 1.5em Arial,Helvetica,Geneva,sans-serif;color:#336699;background-color:#F8F8F8;border-bottom: 3px double #336699; display: inline-block;margin-top:0pt;margin-bottom:0pt;padding:0px 0px 0px 0px;' },
prompt { selector: 'h2             ', rules: 'font:bold 1.4em Arial,Helvetica,Geneva,sans-serif;color:#336699;background-color:#F8F8F8;;border-bottom: 3px double #336699; display: inline-block;margin-top:4pt;margin-bottom:0pt;' },
prompt { selector: 'h3             ', rules: 'font:bold 1.3em Arial,Helvetica,Geneva,sans-serif;color:#336699;background-color:#F8F8F8;;border-bottom: 3px double #336699; display: inline-block;margin-top:4pt;margin-bottom:0pt;' },
prompt { selector: 'li             ', rules: 'font:1em Arial,Helvetica,Geneva,sans-serif;color:black;' },
prompt { selector: 'pre            ', rules: 'font:.7em Courier;color:#000;background:#fff;' },
prompt { selector: 'ul             ', rules: 'list-style-type:circle;margin:1em;padding:0;background:#F8F8F8;' },
prompt { selector: 'p              ', rules: 'color:#630; font-size: 1em;' },
prompt { selector: '*              ', rules: 'box-sizing: border-box;' },
prompt ];;

prompt function quote ( line ){return ( "\"" + line + "\"" );}
prompt function addMenu() { var headings = []; var tag_names = { h1:1, h2:1, h3:1, h4:1, h5:1, h6:1 }; function walk( root ) { if( root.nodeType === 1 && root.nodeName !== 'script' ) { if( tag_names.hasOwnProperty(root.nodeName.toLowerCase()) ) { headings.push( root ); } else { for( var i = 0; i < root.childNodes.length; i++ ) { walk( root.childNodes[i] ); } } } } function writemenu() { var anchor_name = ""; var heading_title = ""; var r0 = ""; var r1 = ""; var r2 = ""; var r3 = ""; for( var i = 0; i < headings.length; i++ ) { heading_title = headings[i].innerHTML.trim(); anchor_name = heading_title.split ( " " ).join ( "_" ).trim(); r0 =  "<li><a href=" + quote ( "#" + anchor_name ) + ">" + heading_title + "</a></li>"; if ( i <= headings.length/3 ) { r1 = r1 + r0; } else { if ( i <= headings.length/3*2) { r2 = r2+ r0; } else { r3 = r3 + r0; } } } r0 = "<table><tr valign=top><td><ul>" + r1 + "</ul></td><td><ul>" + r2 + "</ul></td><td><ul>" + r3 + "</ul></td></tr></table>"; document.getElementById('Menu1').innerHTML = r0; } walk( document.body ); writemenu();}
prompt function addRule(stylesheetId, selector, rule) { var stylesheet = document.getElementById(stylesheetId); if (stylesheet) { stylesheet = stylesheet.sheet; if (stylesheet.addRule) { stylesheet.addRule(selector, rule); } else if (stylesheet.insertRule) { stylesheet.insertRule(selector + ' { ' + rule + ' }', stylesheet.cssRules.length); } } }
prompt function addRules() { var index; for (index = 0; index < cssRules.length; index++) { addRule("myStyles", cssRules[index].selector.trim(), cssRules[index].rules); } }
prompt { addMenu(); addRules(); }

prompt </script>

spool off

set define on
set term on
prompt Finished. The spool file is mcl.html
quit
prompt <a href="#z-header">Back to Top</a>
